### 背包问题

dd大牛的《背包九讲》

https://www.cnblogs.com/jbelial/articles/2116074.html

<img src="https://inews.gtimg.com/newsapp_ls/0/14515472144/0.jiketuchuang.png" alt="image.png" title="image.png" />



01背包：

N, w[i], v[i], 

给定w，每件物品只能选或不选，最大化的total value， 

如果是二维的情况下，每一个$dp[i][j]$都需要更新，因为如果不更新则为0

如果是一维的情况下，则对 j < w[i]的不需要更新，因为它会直接从上一层拷贝，没有重新写的就相当于拷贝。

如何理解重复使用第i件物品多次：

<img src="https://inews.gtimg.com/newsapp_ls/0/14522135773/0.jiketuchuang.png" alt="image.png" title="image.png" />

完全背包：	







#### 01背包：

问题描述：

有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

##### [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

性质：判断是否有子集恰好能够装满target

参数：dp, target,

关键点：

- 求容量为target的背包里能够放到最大价值的物品是否为target
- w <= target，只有当w == target时，说明是正确的。否则为错误的

思路：相当于向容量为target的背包里放物品，物品大小为w，价值也为w，因为物品总大小一定小于等于target
所以物品总价值也是一定小于等于target。先遍历物品，然后再遍历背包，采用降维方法，相当于对上一行的数据拷贝到改行。然后为防止重复放置物品，就需要从后往前遍历。

因为考虑到会使用到 dp【i]【j] = dp【i-1][j]等，所以需要初始化第一行，这时候我们就可以令dp = [[0]*(target+1) for _ in range(len(nums)+1)]， 这样就不用初始化第一行了，让 dp【i]【j]表示使用前i个元素填充大小为j的背包。

##### [1049. 最后一块石头的重量 II](https://leetcode-cn.com/problems/last-stone-weight-ii/)

性质：求容量为sum//2的背包里能装的最大重量，然后用该最大重量得到相抵消后的最小重量

参数：total， target, dp, 

关键：

- 重量为w，价值也为w，求容量为target的背包能放的最大的重量，这个和上一题一模一样，不同的是求得最后结果不一样
- 因为重量和价值一样，所以在对物品进行遍历的时候可以直接使用 for stone in stones:, 如果重量和价值不一样就需要索引了，所以要用for i in range(len(stones)).

思路： 和上一题基本上一样。



##### [494. 目标和](https://leetcode-cn.com/problems/target-sum/)

性质：

可以采用回溯方法，但是回溯方法对于备选元素超过20个的情况就会出现超时间的问题。1024 * 1024， 

因此需要采用动态规划的方法，相当于向一个总量为target的背包里防止物品，物品的个数为len(nums), 重量和价值都为nums[i], 每个物品只可以使用一次，问有多少种放置物品的方法。

递推公式：面对一个物品，有放或不放两种选择，如果放不下，那就和不放的结果相等，如果放得下，那就需要加上出去该物品之后的物品放入的方法数。dp[j] += dp[j - nums[i]]，也就是dp[j]可以由前面的结果推出，是前面结果的和。先遍历物品，然后再遍历背包。初始值设置为dp[0] = 1，其它的为0.

- dp[i]【j】使用前i个来凑target的方法数。





？？ 面对组合问题，神魔时候回溯法会超时。

根据备选元素的大小来判断： 回溯法只能应对备选元素小于20多的情况，







##### [474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)

性质：将集合划分为两个子集，相当于将集合中的物品放到背包中去，背包的总量为m个0, n个1，每个物品的重量也为0和1的个数，物品的价值是1，最终求背包中能够放置的最多的物品数量，也就是求背包能装的最大价值。因此属于两个维度的01背包问题。

很有意思的题目。



#### 完全背包

有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大。

对纯完全背包问题，遍历顺序没有关系，因为因为纯完全背包求得是能否凑成总和，和凑成总和的元素有没有顺序没关系，即：有顺序也行，没有顺序也行！

完全背包： 与求组合数和求排列数之间的区别

- 如果求组合数就是外层for循环遍历物品，内层for遍历背包。
- 如果求排列数就是外层for遍历背包，内层for循环遍历物品。

[322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

##### [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

给出可以凑成总金额的硬币组合数， 硬币可以无限使用，为完全背包问题。

性质：明确状态和选择， 状态是背包的容量和可选择的物品， 选择就是转进背包和不装进背包。	$dp[i][j]$ 表示如果只使用前i件物品，（物品可以重复使用）当背包容量为j时，有$dp[i][j]$种方法可以装满背包。

递推公式：$dp[i][j]= dp[i-1][j] + dp[i][j - coin[i-1]]$,如何体现重复使用，就是我使用或者不适用该硬币。如果不使用，就是用前面的i-1个硬币来凑j，如果使用就是用前面i个硬币来凑j-coin[i-1]。 这里是j - coin[i-1]是因为我们用的是前i个硬币，这时候第i个硬币的下标就是coin[i-1].



这里求的是能够凑成amount的方法的数量，属于是组合问题，先遍历物品，后遍历背包。

排列与组合：

https://www.codeleading.com/article/90455739854/



先把需要用到的物品找到，再把背包容量找到，然后再进行。







总结：

时间复杂度：

https://www.cxyxiaowu.com/11973.html

01背包：

有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

要有一个背包，然后还有一组物品，对每一个物品判断是会否将其放入背包。如果不放入背包，就简化为前面i-1个物品的放背包；如果放入背包，就简化为前面i-nums[i]个物品放背包+nums[i]。因此这种情况就可以使用动态规划。
