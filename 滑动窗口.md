 	x·滑动窗口，

example 1：

字符串的最长不重复子序列：



剑指offer57：

https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/solution/shi-yao-shi-hua-dong-chuang-kou-yi-ji-ru-he-yong-h/

la大佬：我写了首诗，把滑动窗口算法算法变成了默写题

https://labuladong.gitee.io/algo/2/21/60/

[209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

- [76. 最小覆盖子串（困难）](https://leetcode-cn.com/problems/minimum-window-substring)
- [567. 字符串的排列（中等）](https://leetcode-cn.com/problems/permutation-in-string)
- [438. 找到字符串中所有字母异位词（中等）](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string)
- [3. 无重复字符的最长子串（中等）](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters)

滑动窗口总结：

###### 76最小覆盖子串：

参数：s， t

need, window, valid, left, right, start, length:

寻找最小的覆盖子串，窗口的长度不定，是一个最优化问题

思路：right向右移动，先找到一个可行解，然后再向右移动left得到最优解

关键：变量比较多，初始化的时候尽量不要连等，对于mutable 变量，连等是非常危险的，因为你不是创建了两个变量，而是创建了一个变量。

###### 567字符串的排列

参数：s，t

need，window, valid,left, right,

看s中是否存在t的排列，窗口的长度一定，是一个存在性问题，也就是找到一个可行解就可以了

思路：right向右移动，直到right - left == len(t)，为一个可能解，判断valid == len(need)，如果成立，则存在。

###### 438找到字符串中所有字母异位词

参数：s，t

need, window, valid, left, right, res

找到s中所有t的排列，窗口长度是一定的，是一个求所有解的问题，要找到所有解

思路：right向右移动，直到形成窗口right - left == len(t)，然后看是否为解，如果为解，则添加到res中。然后看以left + 1为起点的子串是否为排列。

###### 3无重复字符的最长子串

参数：s

window，left， right， res

window为窗口，记录窗口中的字符情况，如果出现某个字符次数为多次，那就要消除这个重复字符。right前进用来增加window中的字符数量，left前进，用来减少window中的字符数量。



找到无重复的最长子串，窗口长度不一定，是一个最优化问题

思路：right 向右移动，没移动一次更新一次最长无重复的长度res，直到遇到重复，left向右移动，直到没有重复，更新res的结果。



###### 剑指57[和为s的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)

1 - 8 的例子

参数： s

left, right, cursum, res

找到和为s的所有正数序列，窗口长度不一定，是个求所有可能解的问题

思路：right向右移动，直到curSum >= s，则left向右移动，直到curSum <= s,目标是得到curSum == s对应的left和right，当相等的时候，把结果添加到res中，并且left += 1，因为以left为开头的结果没有了，要看以left + 1为开头的结果是否存在。 

- 注意while的进入条件，left <= target // 2， 当left > target // 2时，结果一定是不存在的，因此令while <= target // 2，而right > target // 2结果是可能存在的。

[剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)

单调递增队列

单调队列也很有意思： 

单调递增（递减）队列， 单调递减队列维护最大值，单调递增队列维护最小值。

队列有先进先出的特点，

如何在队列变化时，对最大值进行维护。维护一个递减队列，



###### [424. 替换后的最长重复字符](https://leetcode-cn.com/problems/longest-repeating-character-replacement/)

https://leetcode-cn.com/problems/longest-repeating-character-replacement/solution/ti-huan-hou-de-zui-chang-zhong-fu-zi-fu-eaacp/

**这个问题还是非常有意思的**













#### 总结：

滑动窗口一般解决连续子串或者子串是否存在的问题。

参数理解

- window用来存储窗口中遇到的字符数量情况。
- left和right用来控制window的变化
- need是window的目标，用来判断window是否是一个可行解

题型总结：

在s中找t

- 76最小覆盖子串是先让right不断增大，想window中添加目标元素，知道找到一个可行解。然后在保证为可行解的情况下，移动left，不断优化可行解，知道找到最优的解。
- 567字符串的排列是和上一个是一样的，right移动找到一个可行解，然后移动left，得到一个最优解（只不过，排列要求紧密）
- 438找到所有排列的起始索引（left），和上一题思路相同，不过是要求找到所有的排列，因此找到一个之后，left要继续移动。直到找到所有的结果

只和一个s的窗口有关：

- 3.无重复的最长子串， 既找到s中最长的不重复的子串长度。还是用window记录窗口中的情况。right不断向前，扩张window大小，直到遇到重复，让left向前。right每向前移动一次，就更新一次结果。
- 59.滑动窗口的最大值， 就是找到移动过程中滑动窗口的每一个最大值。主要是用到了单调队列，这是因为滑动窗口的最大值只和最大的有关，小于最大值的就是无用的。就可以创建一个单调递减的队列，保证队列最前面的一定是最大的。窗口中添加和删除值都会影响队列的最大值。窗口每向前移动一步，就需要更新一次队列，并添加结果到res中。
- 57找到和为target的连续正数序列。就需要遍历所有可能的连续正数序列，l最大能取target的一半。当totoal < target时，窗口扩张；反之则窗口缩减。结果在l到r之间的所有数。

20.长度最小的子数组。找到使连续子数组和大于target的最短子数组。
