# Leetcode 题解 - 排序
<!-- GFM-TOC -->

* [Leetcode 题解 - 排序](#leetcode-题解---排序)
    * [快速选择](#快速选择)
    * [堆](#堆)
        * [1. Kth Element](#1-kth-element)
    * [桶排序](#桶排序)
        * [1. 出现频率最多的 k 个元素](#1-出现频率最多的-k-个元素)
        * [2. 按照字符出现次数对字符串排序](#2-按照字符出现次数对字符串排序)
    * [荷兰国旗问题](#荷兰国旗问题)
        * [1. 按颜色进行排序](#1-按颜色进行排序)
        <!-- GFM-TOC -->


## 快速选择

用于求解   **Kth Element**   问题，也就是第 K 个元素的问题。

可以使用快速排序的 partition() 进行实现。需要先打乱数组，否则最坏情况下时间复杂度为 O(N<sup>2</sup>)。

## 堆

用于求解   **TopK Elements**   问题，也就是 K 个最小元素的问题。使用最小堆来实现 TopK 问题，最小堆使用大顶堆来实现，大顶堆的堆顶元素为当前堆的最大元素。实现过程：不断地往大顶堆中插入新元素，当堆中元素的数量大于 k 时，移除堆顶元素，也就是当前堆中最大的元素，剩下的元素都为当前添加过的元素中最小的 K 个元素。插入和移除堆顶元素的时间复杂度都为 log<sub>2</sub>N。

堆也可以用于求解 Kth Element 问题，得到了大小为 K 的最小堆之后，因为使用了大顶堆来实现，因此堆顶元素就是第 K 大的元素。

快速选择也可以求解 TopK Elements 问题，因为找到 Kth Element 之后，再遍历一次数组，所有小于等于 Kth Element 的元素都是 TopK Elements。

可以看到，快速选择和堆排序都可以求解 Kth Element 和 TopK Elements 问题。

### 1. Kth Element

215\. Kth Largest Element in an Array (Medium)

[Leetcode](https://leetcode.com/problems/kth-largest-element-in-an-array/description/) / [力扣](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/description/)

```text
Input: [3,2,1,5,6,4] and k = 2
Output: 5
```

题目描述：找到倒数第 k 个的元素。

**排序**  ：时间复杂度 O(NlogN)，空间复杂度 O(1)

```java
public int findKthLargest(int[] nums, int k) {
    Arrays.sort(nums);
    return nums[nums.length - k];
}
```

**堆**  ：时间复杂度 O(NlogK)，空间复杂度 O(K)。

思路：

- 共有N个objects， 想要找到bigest的M个。 可以建立一个minHeap A，将N个objects逐个添加到A中，当A.size() >M的时候，则将最小的object从A中清除出去，这样一直将最小的清除出去，最后得到的就是N个objects中最大的M个。（因为想要得到最大的M个，就要将所有较小的值给清除出去，故使用minHeap）
- 维护一个minHeap，将新值添加到minHeap中，当minHeap的规模大于K时，就删去栈顶元素。对每一个元素都这样操作。

关键点：先将元素添加到minHeap中，然后在对其进行删除。

implementation 1：

```java
public int findKthLargest(int[] nums, int k) {
    PriorityQueue<Integer> pq = new PriorityQueue<>(); // 小顶堆
    for (int val : nums) {
        pq.add(val);
        if (pq.size() > k)  // 维护堆的大小为 K
            pq.poll();
    }
    return pq.peek();
}
```

implementation 2：

inplace heapsort

```java
public int findKthLargest(int[] nums, int k) {
	for (int i = 0; i < k; i++) {
        swim(nums, i);//swim需要起始位置i和终止位置0，不能超出array的范围。
    }
    
    for (int i = k; i < nums.length; i++) {
        if (nums[i] > nums[0]) {//将剩下的元素中比nums[0]大的插进去。
            swap(nums, 0, i);
            sink(nums, 0, k-1);//sink需要起始位置i与终止位置k-1，不能超过minHeap中元素的个数
        }
    }
    return nums[0];
}

//比较a和b的priority，这里值越小，则优先度越高
private boolean priorityThan(int a, int b) {
    return a < b; 
}
//向上升， parent的index只可能是(i-1)/2，只要保证i和(i-1)/2在array范围内就可以了，它等价于i在范围内。

private void swim(int[] nums, int i) {
    while (i > 0 && priorityThan(nums[i], nums[(i-1)/2])) {
        swap(nums, i, (i-1)/2);
        i = (i-1)/2;
    }
}

//向下降，要确定使用哪个children，应该使用priority比较大的那个children。 要保证使用到的i和children的index在范围内，因为大的数容易出界，所以首先是比较小的那个child，然后是比较大的那个child。
//当i在合适位置时，停止循环。
private void sink(int[] nums, int i, int N) {
    while (2*i + 1 <= N) {
        int j = 2*i + 1;
        if (priorityThan(nums[j+1], nums[j])) j++;//和children中priority最高的进行交换
        if (priorityThan(nums[i], nums[j])) break;
        i = j;        
    }
}

private void swap(int[] nums, int i , int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
```

**快速选择**  ：时间复杂度 O(N)，空间复杂度 O(1)

```java
public int findKthLargest(int[] nums, int k) {
    k = nums.length - k;
    int l = 0, h = nums.length - 1;
    while (l < h) {
        int j = partition(nums, l, h);
        if (j == k) {
            break;
        } else if (j < k) {
            l = j + 1;
        } else {
            h = j - 1;
        }
    }
    return nums[k];
}

private int partition(int[] a, int l, int h) {
    int i = l, j = h + 1;
    while (true) {
        while (a[++i] < a[l] && i < h) ;
        while (a[--j] > a[l] && j > l) ;
        if (i >= j) {
            break;
        }
        swap(a, i, j);
    }
    swap(a, l, j);
    return j;
}

private void swap(int[] a, int i, int j) {
    int t = a[i];
    a[i] = a[j];
    a[j] = t;
}
```

patition:

参考：

https://leetcode.com/problems/kth-largest-element-in-an-array/discuss/1712910/QuickSort-QuickSelect-template-for-all-easy-to-understand

首先将nums[end]看做是pivot，然后i从start开始，填充小于等于pivot的值，则最后i为小于等于pivot值的下一个index，是大于pivot的，从而和nums[end]互换，i即为nums[end]的顺序。

```python
def quickSelect(nums, k):
    k = len(nums) - k
    lo, hi = 0, len(nums)-1
    while lo < hi:
        j = patition(nums, lo, hi)
        if j == k:
            break
        elif j > k:
            hi = j - 1
        else:
            lo = j + 1
    return nums[k]





def partition(nums, start, end):
    pivot = nums[end]
    i = start
    for j in range(start, end):
        if nums[j] <= pivot:
            nums[i], nums[j] = nums[j], nums[i]
            i += 1
        
    nums[i], nums[end] = nums[end], nums[i]
```



## 桶排序

### 1. 出现频率最多的 k 个元素

347\. Top K Frequent Elements (Medium)

[Leetcode](https://leetcode.com/problems/top-k-frequent-elements/description/) / [力扣](https://leetcode-cn.com/problems/top-k-frequent-elements/description/)

```html
Given [1,1,1,2,2,3] and k = 2, return [1,2].
```

设置若干个桶，每个桶存储出现频率相同的数。桶的下标表示数出现的频率，即第 i 个桶中存储的数出现的频率为 i。

把数都放到桶之后，从后向前遍历桶，最先得到的 k 个数就是出现频率最多的的 k 个数。

```java
public int[] topKFrequent(int[] nums, int k) {
    Map<Integer, Integer> frequencyForNum = new HashMap<>();
    for (int num : nums) {
        frequencyForNum.put(num, frequencyForNum.getOrDefault(num, 0) + 1);
    }
    List<Integer>[] buckets = new ArrayList[nums.length + 1];
    for (int key : frequencyForNum.keySet()) {
        int frequency = frequencyForNum.get(key);
        if (buckets[frequency] == null) {
            buckets[frequency] = new ArrayList<>();
        }
        buckets[frequency].add(key);
    }
    List<Integer> topK = new ArrayList<>();
    for (int i = buckets.length - 1; i >= 0 && topK.size() < k; i--) {
        if (buckets[i] == null) {
            continue;
        }
        if (buckets[i].size() <= (k - topK.size())) {
            topK.addAll(buckets[i]);
        } else {
            topK.addAll(buckets[i].subList(0, k - topK.size()));
        }
    }
    int[] res = new int[k];
    for (int i = 0; i < k; i++) {
        res[i] = topK.get(i);
    }
    return res;
}

        
```







```java
//基于桶排序求解「前 K 个高频元素」
class Solution {
    public List<Integer> topKFrequent(int[] nums, int k) {
        List<Integer> res = new ArrayList();
        // 使用字典，统计每个元素出现的次数，元素为键，元素出现的次数为值
        HashMap<Integer,Integer> map = new HashMap();
        for(int num : nums){
            if (map.containsKey(num)) {
               map.put(num, map.get(num) + 1);
             } else {
                map.put(num, 1);
             }
        }
    
//桶排序
    //将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标
    List<Integer>[] list = new List[nums.length+1];
    for(int key : map.keySet()){
        // 获取出现的次数作为下标
        int i = map.get(key);
        if(list[i] == null){
           list[i] = new ArrayList();
        } 
        list[i].add(key);
    }
    
    // 倒序遍历数组获取出现顺序从大到小的排列
    for(int i = list.length - 1;i >= 0 && res.size() < k;i--){
        if(list[i] == null) continue;
        res.addAll(list[i]);
    }
    return res;
}
```
}

作者：cxywushixion
链接：https://leetcode-cn.com/problems/top-k-frequent-elements/solution/leetcode-di-347-hao-wen-ti-qian-k-ge-gao-pin-yuan-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



```python
## 暴力解法
# 1. 首先得到出现次数统计的map
# 2. 根据map的val对key-val进行排序
# 3. 得到排序前k个的key
def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        map = dict()
        res = []
        for num in nums:
            map[num] = map.get(num, 0)+1

        res = sorted(map.items(), key = lambda kv: kv[1], reverse = True)[:k]
        
        for ls in range(k):
            res[ls] = res[ls][0]
        

        return res
    
    
## heap法
def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        map = dict()
        res = []
        for num in nums:
            map[num] = map.get(num, 0)+1

        res = heapq.nlargest(k, map.items(), key = lambda kv: kv[1])

        for ls in range(k):
            res[ls] = res[ls][0]
        
        return res
    
# heap方法

def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        hashmap = {}
        for num in nums:
            if num in hashmap:
                hashmap[num] += 1
            else:
                hashmap[num] = 1
        heap = []
        for key in hashmap:
            # 用负号将求前k大的，改为求前k小的。
            heapq.heappush(heap, (-hashmap[key], key))
        
        res = []
        for _ in range(k):
            popped = heapq.heappop(heap)
            res.append(popped[1])
        
        return res
    
##Counter
def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        
        return [number for number, occ in Counter(nums).most_common(k)]

```



### 2. 按照字符出现次数对字符串排序

451\. Sort Characters By Frequency (Medium)

[Leetcode](https://leetcode.com/problems/sort-characters-by-frequency/description/) / [力扣](https://leetcode-cn.com/problems/sort-characters-by-frequency/description/)

```html
Input:
"tree"
Output:
"eert"

Explanation:
'e' appears twice while 'r' and 't' both appear once.
So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.
```

```java
public String frequencySort(String s) {
    Map<Character, Integer> frequencyForNum = new HashMap<>();
    for (char c : s.toCharArray())
        frequencyForNum.put(c, frequencyForNum.getOrDefault(c, 0) + 1);

    List<Character>[] frequencyBucket = new ArrayList[s.length() + 1];
    for (char c : frequencyForNum.keySet()) {
        int f = frequencyForNum.get(c);
        if (frequencyBucket[f] == null) {
            frequencyBucket[f] = new ArrayList<>();
        }
        frequencyBucket[f].add(c);
    }
    StringBuilder str = new StringBuilder();
    for (int i = frequencyBucket.length - 1; i >= 0; i--) {
        if (frequencyBucket[i] == null) {
            continue;
        }
        for (char c : frequencyBucket[i]) {
            for (int j = 0; j < i; j++) {
                str.append(c);
            }
        }
    }
    return str.toString();
}
```





## 荷兰国旗问题

荷兰国旗包含三种颜色：红、白、蓝。

有三种颜色的球，算法的目标是将这三种球按颜色顺序正确地排列。它其实是三向切分快速排序的一种变种，在三向切分快速排序中，每次切分都将数组分成三个区间：小于切分元素、等于切分元素、大于切分元素，而该算法是将数组分成三个区间：等于红色、等于白色、等于蓝色。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7a3215ec-6fb7-4935-8b0d-cb408208f7cb.png"/> </div><br>


### 1. 按颜色进行排序

75\. Sort Colors (Medium)

[Leetcode](https://leetcode.com/problems/sort-colors/description/) / [力扣](https://leetcode-cn.com/problems/sort-colors/description/)

```html
Input: [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
```

题目描述：只有 0/1/2 三种颜色。

**有点难，没看懂**

```java
public void sortColors(int[] nums) {
    int zero = -1, one = 0, two = nums.length;
    while (one < two) {
        if (nums[one] == 0) {
            swap(nums, ++zero, one++);
        } else if (nums[one] == 2) {
            swap(nums, --two, one);
        } else {
            ++one;
        }
    }
}

private void swap(int[] nums, int i, int j) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}
```

思考：要求是inplace sort

可以使用insertion sort 速度比较慢，不太实用

因为总共只有三个元素，所以会有很多重复元素。有很多重复元素的排序，可以怎么处理呢？ 直接将所有的0放在前面，1放在0后面，就排序成功啦。

一次遍历：

技巧比较多

两次遍历（patition思想）：

首先把0看做一类，1和2看做一类，这样就可以一遍过，将0放到前面。

然后将2看做一类，0和1看做一类，这样就可以将2放到最后。



快速排序：

```java

public class Solution {

    public void sortColors(int[] nums) {
        int len = nums.length;
        if (len < 2) {
            return;
        }

        // all in [0, zero) = 0
        // all in [zero, i) = 1
        // all in [two, len - 1] = 2
        
        // 循环终止条件是 i == two，那么循环可以继续的条件是 i < two
        // 为了保证初始化的时候 [0, zero) 为空，设置 zero = 0，
        // 所以下面遍历到 0 的时候，先交换，再加
        int zero = 0;

        // 为了保证初始化的时候 [two, len - 1] 为空，设置 two = len
        // 所以下面遍历到 2 的时候，先减，再交换
        int two = len;
        int i = 0;
        // 当 i == two 上面的三个子区间正好覆盖了全部数组
        // 因此，循环可以继续的条件是 i < two
        while (i < two) {
            if (nums[i] == 0) {
                swap(nums, i, zero);
                zero++;
                i++;
            } else if (nums[i] == 1) {
                i++;
            } else {
                two--;
                swap(nums, i, two);//很关键，防止跳过2
            }
        }
    }

    private void swap(int[] nums, int index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }
}
```







### 归并排序

类似于后序遍历

```python
def mergesort(seq):
    """归并排序"""
    if len(seq) <= 1:
        return seq
    mid = len(seq) // 2  # 将列表分成更小的两个列表
    # 分别对左右两个列表进行处理，分别返回两个排序好的列表
    left = mergesort(seq[:mid])
    right = mergesort(seq[mid:])
    # 对排序好的两个列表合并，产生一个新的排序好的列表
    return merge(left, right)

def merge(left, right):
    """合并两个已排序好的列表，产生一个新的已排序好的列表"""
    result = []  # 新的已排序好的列表
    i = 0  # 下标
    j = 0
    # 对两个列表中的元素 两两对比。
    # 将最小的元素，放到result中，并对当前列表下标加1
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result += left[i:]
    result += right[j:]
    return result

seq = [5,3,0,6,1,4]
print '排序前：',seq
result = mergesort(seq)
print '排序后：',result
```



### 快速排序

类似于前序遍历

```python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        def sort(nums, l, r):
            def patition(nums, l, r):
                x = nums[r]
                i = l-1
                for j in range(l, r):
                    if nums[j] > x: continue
                    i += 1
                    nums[i], nums[j] = nums[j], nums[i]
                nums[i+1], nums[r] = nums[r], nums[i+1]
                return i+1
            if l >= r: return
            j = patition(nums, l, r)
            sort(nums, l, j-1)
            sort(nums, j+1, r)
        random.shuffle(nums)
        sort(nums, 0, len(nums)-1)
        return nums
```

```python
## 归并排序：相当于后序遍历，先排序左右两边，然后再将两个排好序的进行归并
## 是递归操作，当只有一个元素的时候直接返回，因为一个元素一定是有序的
## 归并排序与逆序对问题：
题目一：
逆序对：左边的比右边大就是一个逆序对。
两种思路：对左边每个数，寻找右边比它小的所有数的个数（只有当遇到大于等于它的，才能得到所有小于它的）；对右边每个数，找左边比它大的所有数的个数（只有遇到大于它的，才能遇到所有大于它的）
注意：归并过程中，谁小谁先进入排序，也就是说[l, mid]与[mid+1, r],如果nums[i] > nums[j], 那么在左边比nums[j]大的元素有tmp[i, mid]。 如果nums[i] <= nums[j], 那么在右边比nums[i]小的为tmp[mid+1, j-1]
在归并排序过程中，合并阶段本质上是合并两个排序数组的过程，而每当遇到左子数组当前元素 > 右子数组当前元素 时，意味着 「左子数组当前元素 至 末尾元素」 与 「右子数组当前元素」 构成了若干 「逆序对」
题目二：
计算右侧小于当前元素的个数。以 nums[i] 为左端点的「逆序对」的数目。
关键：在常规的归并排序过程中，数组中的元素其位置会发生变化，而在本题中我们则需要记录下每个元素的初始位置，以便将每个元素贡献的逆序对数目归功到对应的位置上。

## 归并排序和求交集问题
问题一：两个数组的交集
方法一：hashset方法
方法二：双指针法
首先对nums1和nums2进行排序，然后使用归并的方法逐渐去寻找两个数组之间的相同元素。归并的时候就是寻找两个排序数组中最相近的两个元素，因此可以用来寻找两数组里的交集。 如果不进行去重，得到的就是所有重复相同的元素。
方法三：使用二分查找


def mergeSort(l, r):
            if l >= r: return 0
            m = (l+r)//2
            res = mergeSort(l, m) + mergeSort(m+1, r)
            i, j = l, m+1
            tmp[l:r+1] = nums[l:r+1]
            for k in range(l, r+1):
                if i == m+1: 
                    nums[k] = tmp[j]
                    j += 1
                elif j == r+1: 
                    nums[k] = tmp[i]
                    i += 1
                elif tmp[i] <= tmp[j]:
                    nums[k] = tmp[i]
                    i += 1
                else:
                    nums[k] = tmp[j]
                    j += 1
                    res += m-i+1
            return res
        
def mergeSort(nums):
    def mergeS(nums, l, r):
        def merget(nums, l, r, m)
        	i, j = l, m+1
            tmp[l:r+1] = nums[l:r+1]
            for k in range(l,r+1):
                if i == m+1: 
                    nums[k] = tmp[j]
                    j+=1
                elif j == r+1:
                    nums[k] = tmp[i]
                    i += 1
                elif tmp[i] <= tmp[j]:
                    nums[k] = tmp[i]
                    i += 1
                else:
                    nums[k] = tmp[j]
                    j += 1
        if l >= r: return
        m = l + (r-l)//2
        mergeS(nums, l, m)
        mergeS(nums, m+1, r)
        merge(nums, l, r, m)
        
    tmp = [0]*len(nums)
    mergeS(0, len(nums)-1)
    return nums

## 选择排序
选择排序(Selection Sort)是一种简单直观的排序算法。它的工作原理是：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完成。
def selectSort(nums):
    n = len(nums)
    if n <= 1: return
    
    for i in range(n):
        maxIdx = i
        maxValue = nums[i]
        for j in range(i, n):
            if nums[j] > maxValue:
                maxIdx = j
                maxValue =num[j]
		nums[i], nums[maxIdx] = nums[maxIdx], nums[i]
## 插入排序
插入排序(Insertion Sort)是一种简单直观的排序算法。它的工作原理是：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
## 插入排序不改变相对位置，因此是稳定的算法。
题目1: 将0移动到最后，不改变其它元素的相对顺序
    将非0元素放到前面，因为是直接交换，先遇到谁，谁就到前面，因此是不会改变相对顺序的
题目2：将指定的元素1、6、3移动到末尾，并且需要保持所有元素的相对顺序。
	使用插入排序的方法，从后往前遍历，遇到1， 6, 3就通过逐个交换的方法将它移动到后面
def insertSort(nums):
    n = len(nums)
    if n <= 1: return
    
    for i in range(1, n):
        value = nums[i]
        j = i - 1
        while j >= 0 and nums[j] > value:
            nums[j+1] = nums[j]
            j -= 1
		nums[j+1] = val
   	for i in range(1, n):
        j = i
        ## 这里是遍历到合适的位置就可以了
        while j > 0 and nums[j] < nums[j-1]:
            nums[j], nums[j-1] = nums[j-1], nums[j]
            j -= 1
            
## 冒泡排序
https://segmentfault.com/a/1190000022687027
## 冒泡排序(Bubble Sort)是经典排序算法之一，属于交换排序的一种，基本的排序思路是：从头开始两两元素进行比较，大的元素就往上冒，这样遍历一轮后，最大的元素就会直接筛选出来。然后再重复上述操作，即可完成第二大元素的冒泡。以此类推，直到所有的元素排序完成。
def bubbleSort(nums):
    n = len(nums)
    for i in range(n):
## 到第i个，说明已经有i个排好序了，所以前面有n-i个,坐标范围是[0, n-i-1]，又因为需要比较nums[j]和nums[j+1]。所以j就要取[0, n-i-2]

		## 这里是一直向后遍历，直到把最大的放到最后位置
        for j in range(n-i-1):
            if nums[j] > nums[j+1]:
                nums[j], nums[j+1] = nums[j+1], nums[j]
        

## 桶排序， 
能够做到时间复杂度为O(n)，但是会用到额外的空间，这个额外的空间取决于你数的大小，如果元素取值不是很多的话，就可以用

## 基数排序

        
        

```



![image-20220502231425878](C:\Users\Mrcao\AppData\Roaming\Typora\typora-user-images\image-20220502231425878.png)





树状数组：

为啥会有这样的数据结构，主要解决前缀数组



[280. 摆动排序](https://leetcode.cn/problems/wiggle-sort/)

方法一：

思路是先给数组排个序，然后我们只要每次把第三个数和第二个数调换个位置，第五个数和第四个数调换个位置，以此类推直至数组末尾，这样我们就能完成摆动排序了

方法二：

1.主要看index的奇偶性，来判断是山峰还是山谷

peak or valley

2.因为是从左往右，左边的肯定都是经过计算和交换的。

只需关心右侧的

```python
class Solution:
    def wiggleSort(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        for i in range(n - 1):
            if i % 2 == 0:
                if nums[i] > nums[i+1]:
                    nums[i], nums[i+1] = nums[i+1], nums[i]
            else:
                if nums[i] < nums[i+1]:
                    nums[i], nums[i+1] = nums[i+1], nums[i]


```

[324. 摆动排序 II](https://leetcode.cn/problems/wiggle-sort-ii/)

思路：

先决定大数的位置，然后再决定小数子的位置。
