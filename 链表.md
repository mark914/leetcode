



# Leetcode 题解 - 链表



<!-- GFM-TOC -->

* [Leetcode 题解 - 链表](#leetcode-题解---链表)
    * [1. 找出两个链表的交点](#1-找出两个链表的交点) 双指针法 + 固定值
    * [2. 链表反转](#2-链表反转)  iterate（分为两部分+链表截取） and recursion（one by one)
    * [3. 归并两个有序的链表](#3-归并两个有序的链表)  recursion（两个链表结合，一空返回另一个）
    * [4. 从有序链表中删除重复节点](#4-从有序链表中删除重复节点) iterate（双指针） and recursion（直接对head.next进行操作）
    * [5. 删除链表的倒数第 n 个节点](#5-删除链表的倒数第-n-个节点) 指针+dummy+逆向转正向（对链表进行remove、add、拼接等，都需要dummy node。）
    * [6. 交换链表中的相邻结点](#6-交换链表中的相邻结点) iterate（考虑3个需要next的node） and recursion（两个两个考虑）对链表进行修改
    * [7. 链表求和](#7-链表求和) 逆向转正向（stack） + 链表插入（dummy）+位求和
    * [8. 回文链表](#8-回文链表) 双指针（ArrayList）+  快慢指针（没搞明白）
    * [9. 分隔链表](#9-分隔链表) 链表截取 + 指针 +length
    * [10. 链表元素按奇偶聚集 ](#10-链表元素按奇偶聚集) 奇偶判断（true or false）+链表添加（dummy）+链表拼接
    <!-- GFM-TOC -->


链表是空节点，或者有一个值和一个指向下一个链表的指针，因此很多链表问题可以用递归来处理。

##  1. 找出两个链表的交点

160\. Intersection of Two Linked Lists (Easy)

[Leetcode](https://leetcode.com/problems/intersection-of-two-linked-lists/description/) / [力扣](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/description/)

例如以下示例中 A 和 B 两个链表相交于 c1：

```html
A:          a1 → a2
                    ↘
                      c1 → c2 → c3
                    ↗
B:    b1 → b2 → b3
```

但是不会出现以下相交的情况，因为每个节点只有一个 next 指针，也就只能有一个后继节点，而以下示例中节点 c 有两个后继节点。

```html
A:          a1 → a2       d1 → d2
                    ↘  ↗
                      c
                    ↗  ↘
B:    b1 → b2 → b3        e1 → e2
```



要求时间复杂度为 O(N)，空间复杂度为 O(1)。如果不存在交点则返回 null。

**思路：**

设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。

如果没有公共部分，那么c = 0, a + b = b + a仍然成立。

**解法**：

![image.png](https://dd-static.jd.com/ddimg/jfs/t1/185670/6/21209/167097/61279c5fE67b49275/823a1d3b8b56b51f.png)

​	给出两个指针`l1`, `l2`，当访问 A 链表的指针访问到链表尾部时，令它从链表 B 的头部开始访问链表 B；同样地，当访问 B 链表的指针访问到链表尾部时，令它从链表 A 的头部开始访问链表 A。

- 如果两个链表存在交点，由于a + c + b = b + c + a， 这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。
- 如果不存在交点，由于a + b = b + a，以下实现代码中 l1 和 l2 会同时为 null，从而退出循环
- 如果l1 == null，那么就没有next了。注意：要让l1有等于null的机会，所以不能让l1.next == null, 如果这样，l1永远无法等于null
- 关键
  - 相交意味着对象相同，而不是值相等
  
    


```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    ListNode l1 = headA, l2 = headB;
    while (l1 != l2) {
        l1 = (l1 == null) ? headB : l1.next;
        l2 = (l2 == null) ? headA : l2.next;
    }
    return l1;
}
```

如果只是判断是否存在交点，那么就是另一个问题，即 [编程之美 3.6]() 的问题。有两种解法：

- 把第一个链表的结尾连接到第二个链表的开头，看第二个链表是否存在环；
- 或者直接比较两个链表的最后一个节点是否相同。

```python
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        A, B = headA, headB
        while A != B:
            A = A.next if A else headB
            B = B.next if B else headA

        return A
    
   	def get(headA, headB):
        A, B= headA, headB
        while A != B:
            A = A.next if A else headB
            B = B.next if B else headA
        return A
```

方法二：

使用将headA中的node都保存在set中，然后看headA的node中第一个存在于set中的，几位结果

```java
public ListNode getIntserectionNode(ListNode headA, ListNode headB) {
    ListNode pA = headA, pB = headB;
    Set<ListNode> set = new HashSet<>();
    while(pA != null) {
        set.add(pA);
        pA = pA.next;
    }
    
    while (pB != null) {
        if (set.contains(pB)){
            return pB;
        }
        pB = pB.next;
    }
    return null;
}
```



##  2. 链表反转

206\. Reverse Linked List (Easy)

[Leetcode](https://leetcode.com/problems/reverse-linked-list/description/) / [力扣](https://leetcode-cn.com/problems/reverse-linked-list/description/)

递归

```java
public ListNode reverseList(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    ListNode next = head.next;
    ListNode newHead = reverseList(next);
    next.next = head;
    head.next = null;
    return newHead;
}
```

头插法

```java
public ListNode reverseList(ListNode head) {
    ListNode newHead = new ListNode(-1);
    while (head != null) {
        ListNode next = head.next;
        head.next = newHead.next;
        newHead.next = head;
        head = next;
    }
    return newHead.next;
}
```

我的方法：

method one:

思路：

- **如果head的长度小于等于1：那么head本身就是它的reverse**
- **如果大于1：从前往后处理，用head表示已经reverse好的部分，用p表示没有reverse的部分，每次reverse一个value，用temp存储。**

```java
public ListNode reverseList(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    ListNode p = head.next;
    head.next = null;
    ListNode temp;
    
    while (p != null) {
        temp = p;
        p = p.next;
        temp.next = head;
        head = temp;
    }
    return head;   
    
}
```

method two: recursion

![image.png](https://dd-static.jd.com/ddimg/jfs/t1/202993/40/3219/289061/6127abe3E5d10ef88/4d8a3ad8bb645e44.png)

thinking recursively，reverseList就是能够让一个链表reverse，但是它不会改变head.next指向谁，head.next指向的仍然是相邻的那一个元素。该相邻元素现在是reverse的最后一个元素，因此只要让他的next存储为第一个元素，并让head.next = null，就可以了.

要注意哪个是第一个

```python
def reverseList(self, head: ListNode) -> ListNode:
        if head is None or head.next is None:
            return head
        p = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return p
```





### [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

翻转链表的一部分

- 翻转链表的前n个元素：迭代或者递归的方法

  - ![image-20220802222856918](C:\Users\Mrcao\AppData\Roaming\Typora\typora-user-images\image-20220802222856918.png)
  - 迭代方法，是使用翻转[a, b)之间的节点来处理的

- 翻转链表从a到b节点之间的元素[a, b)，**左闭右开的区间：迭代的方法** 

  翻转整个列表，就是在翻转从头结点到null[head, null)之间的节点。

​    head.next = self.reverseBetween(head.next, left-1, right-1)

### [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

和迭代的方法翻转链表从a到b节点之间的元素几乎是一模一样，只不过这里

a.next = self.reverseGroupK(b, k).



关键：

本质上是翻转从a到b之间的节点

迭代的方法：

- 用p来记录翻转的过程，p的起始位置为a.next, 终止位置为b
- 第一个节点是最后一个节点，该最后节点需要连接b





##  3. 归并两个有序的链表

21\. Merge Two Sorted Lists (Easy)

[Leetcode](https://leetcode.com/problems/merge-two-sorted-lists/description/) / [力扣](https://leetcode-cn.com/problems/merge-two-sorted-lists/description/)

思路：

我的解法和该解法差不多，归并两个有序链表，返回一个有序链表。 新建链表只能从后往前添加，这就和recursion的规则相同了，因此可以使用递归。

关键：

链表天生就具有递归的性质，去掉前面的仍然还是一个链表

将比较小的后面部分和另一个整体的merge到一起。

```java
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    if (l1 == null) return l2;
    if (l2 == null) return l1;
    if (l1.val < l2.val) {
        l1.next = mergeTwoLists(l1.next, l2);
        return l1;
    } else {
        l2.next = mergeTwoLists(l1, l2.next);
        return l2;
    }
}
```

循环解法：

```java
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    ListNode dummy = new ListNode(1);
    ListNode p = dummy;
    while (l1 != null && l2 != null) {
        if (l1.val < l2.val) {
            p.next = new ListNode(l1.val);
            l1 = l1.next;
        } else {
            p.next = new ListNode(l2.val);
            l2 = l2.next;
        }
        p = p.next;
    }
    p.next = (l1 == null) ? l2: l1;
    reuturn dummy.next;
}
```

关键：

- 添加节点需要dummy节点，修改需要指针
- 每次添加需要将指针向后移动一位。

##  4. 从有序链表中删除重复节点

83\. Remove Duplicates from Sorted List (Easy)

[Leetcode](https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/) / [力扣](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/description/)

思路：和我的思路差不多

不同的是这里用的是short hand if 语句，可以学习一下。

关键点：有序链表中的重复值一定是相邻的两个value。

使用递归的方法会更加容易解决：

base case: head的长度小于等于1

recursion: 对后面一部分进行recursion，得到已经删除好的有序列表。然后进行操作

易错点：output为一个ListNode。

```html
Given 1->1->2, return 1->2.
Given 1->1->2->3->3, return 1->2->3.
```

```java
public ListNode deleteDuplicates(ListNode head) {
    if (head == null || head.next == null) return head;
    head.next = deleteDuplicates(head.next);
    return head.val == head.next.val ? head.next : head;
}
```

```python
 def deleteDuplicates(self, head: ListNode) -> ListNode:
        if (head == None or head.next == None):
            return head
        head.next = self.deleteDuplicates(head.next)
        return head.next if (head.val == head.next.val) else head
```

双指针法：

删除一个node，删除需要两个next，所以需要cur 和 cur.next都不为null

如果要使用next，则不能为空指针（null）

```java
public ListNode deleteDuplicates(ListNode head) {
    if (head == null || head.next == null)  return head;
    
    ListNode cur = head;
    while (cur.next != null) {
        if (cur.val == cur.next.val) {
            cur.next = cur.next.next;
        } else {
            cur = cur.next;
        }
    }
    return head;
}
```



##  5. 删除链表的倒数第 n 个节点

19\. Remove Nth Node From End of List (Medium)

[Leetcode](https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/) / [力扣](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/description/)



```html
Given linked list: 1->2->3->4->5, and n = 2.
After removing the second node from the end, the linked list becomes 1->2->3->5.
```

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode fast = head;
    while (n-- > 0) {
        fast = fast.next;
    }
    if (fast == null) return head.next;
    ListNode slow = head;
    while (fast.next != null) {
        fast = fast.next;
        slow = slow.next;
    }
    slow.next = slow.next.next;
    return head;
}
```

我的方法：

思路：要考虑好极限情况，n = 1和n = 30的情况。

关键点：

如何处理nullpointer的情况，添加一个dummy 位置就好了。

只要地址相同，对一个的修改就会影响另一个，下面解法中令`ListNode p = dummy`就是为了让`p`来表示需要remove的结点前面的一个结点，对它进行处理，就会影响dummy。

因为链表是有方向的，只能从前往后遍历。所以，首先确定链表的长度length，然后再反推得到前一个结点的位置，然后对该结点进行处理。

- 长度为length，倒数第n个的位置其实就是length - n
- 删除一个node，需要其前面的一个node，比如删除第1个，需要移动0次。所以删除第length - n个，需要移动length-n-1次。
- 一般 i = 0, i < n是循环n次，所以i = 1开始就是循环n-1次。
- 



```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode dummy = new ListNode(0, head);
    int length = getLength(dummy);
    ListNode p = dummy;
    
    for (int i = 1; i < length-n; i += 1) {
        p = p.next;
    }
    p.next = p.next.next;
    return dummpy.next;    
}

public int getLength(ListNode p){
    int length = 0;
    while(p != null) {
        length += 1;
        p = p.next;
    }
    return length;
}
```



方法二：堆方法

需要得到前一个node，这样就可以对前一个node进行修改。使用stack得到前一个node。为保证存在前一个node，还是需要dummy节点。

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode dummy = new ListNode(0, head);
    Stack<ListNode> stack = new Stack<>();
	ListNode cur = dummy;
        
	while (cur != null) {
        stack.push(cur);
        cur.next;
    }
        
    while (n-- > 0) {
        stack.pop();
    }
    
    ListNode pred = stack.peek();
    pred.next = pred.next.next;        
    return dummy.next;
}
```



##  6. 交换链表中的相邻结点

24\. Swap Nodes in Pairs (Medium)

[Leetcode](https://leetcode.com/problems/swap-nodes-in-pairs/description/) / [力扣](https://leetcode-cn.com/problems/swap-nodes-in-pairs/description/)

```html
Given 1->2->3->4, you should return the list as 2->1->4->3.
```

题目要求：不能修改结点的 val 值，O(1) 空间复杂度。

```java
public ListNode swapPairs(ListNode head) {
    ListNode node = new ListNode(-1);
    node.next = head;
    ListNode pre = node;
    while (pre.next != null && pre.next.next != null) {
        ListNode l1 = pre.next, l2 = pre.next.next;
        ListNode next = l2.next;
        l1.next = next;
        l2.next = l1;
        pre.next = l2;

        pre = l1;
    }
    return node.next;
}
```

我的解法：

使用递归解决，空间复杂度为O(n)， 应该是不合格的。

思路：

![image.png](https://dd-static.jd.com/ddimg/jfs/t1/204271/8/3265/186065/6127cf46Eb0029f03/b32cbf5960152c8d.png)





```java
public ListNode swapPairs(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    ListNode newhead = head.next;
    head.next = swapPairs(newhead.next);
    newhead.next = head;
    return newhead;
}
```

使用循环方法：

链表中交换两个node位置，需要3个node的参与，并且被交换的两个node必须要是存在的。又因为每次交换两个node的位置，所以每次指针向前走两步 `p = p.next.next`.

**关键点：**当我们需要对某个node的next进行操作的时候，我们就需要把这个node记录下来，比如交换两个node的位置，就需要对3个node的next进行操作，因此要把他们都记录下来。

**当你需要对node.next进行修改的时候，就需要一个指向它的指针。**

**当你需要对链表进行修改的时候，需要创建一个它的指针对它进行修改，这样就不会改变它本身的地址。**

交换链表的两个node（node1和node2），需要这两个前面的fnode，因为fnode的next会改变，送一总共需要3个指针，一个fnode，一个node1，一个node2.所以需要一个dummy位置。

————————————

11.10 总共需要4个连续的node，也就是说要保证三个结点不是null，首先第一个因为是dummy，所以肯定不是null，所以要保证第二个和第三个不是null。

然后就需要前面的一个结点temp和当事的两个结点left、right

关键点：列表是单向的

```java
public ListNode swapPairs(ListNode head) {
    ListNode newHead = new ListNode();
    newHead.next = head;
    ListNode p = newHead;
    
    while(p.next != null && p.next.next != null) {
        temp = p;
        left = p.next;
        right = left.next;
        
        temp.next = right;
        left.next = right.next;
        right.next = left;
        
        p = p.next.next;        
    }
}
```



##  7. 链表求和

445\. Add Two Numbers II (Medium)

[Leetcode](https://leetcode.com/problems/add-two-numbers-ii/description/) / [力扣](https://leetcode-cn.com/problems/add-two-numbers-ii/description/)

```html
Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 8 -> 0 -> 7
```

题目要求：不能修改原始链表。

```java
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    Stack<Integer> l1Stack = buildStack(l1);
    Stack<Integer> l2Stack = buildStack(l2);
    ListNode head = new ListNode(-1);
    int carry = 0;
    while (!l1Stack.isEmpty() || !l2Stack.isEmpty() || carry != 0) {
        int x = l1Stack.isEmpty() ? 0 : l1Stack.pop();
        int y = l2Stack.isEmpty() ? 0 : l2Stack.pop();
        int sum = x + y + carry;
        ListNode node = new ListNode(sum % 10);
        node.next = head.next;
        head.next = node;
        carry = sum / 10;
    }
    return head.next;
}

private Stack<Integer> buildStack(ListNode l) {
    Stack<Integer> stack = new Stack<>();
    while (l != null) {
        stack.push(l.val);
        l = l.next;
    }
    return stack;
}
```

思路：

关键点：

- 求和方向：求和是从后面向前求的，但链表是从前向后排的，如何能够从后向前提取链表的值。
  - solution：将链表转化为stack，后进先出，符合要求。
- 求和运算：一位一位进行，每位运算需要两数该位上的数x , y，以及从上一位运算中得到的进位carry，输出为改为上的值（sum%10)以及进位 carry（sum/10).

input: x, y, carry

output: sum%10, carry = sum/10;









##  8. 回文链表

234\. Palindrome Linked List (Easy)

[Leetcode](https://leetcode.com/problems/palindrome-linked-list/description/) / [力扣](https://leetcode-cn.com/problems/palindrome-linked-list/description/)

题目要求：以 O(1) 的空间复杂度来求解。

切成两半，把后半段反转，然后比较两半是否相等。

使用的是快慢指针，

```java
public boolean isPalindrome(ListNode head) {
    if (head == null || head.next == null) return true;
    ListNode slow = head, fast = head.next;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    if (fast != null) slow = slow.next;  // 偶数节点，让 slow 指向下一个节点
    cut(head, slow);                     // 切成两个链表
    return isEqual(head, reverse(slow));
}

private void cut(ListNode head, ListNode cutNode) {
    while (head.next != cutNode) {
        head = head.next;
    }
    head.next = null;
}

private ListNode reverse(ListNode head) {
    ListNode newHead = null;
    while (head != null) {
        ListNode nextNode = head.next;
        head.next = newHead;
        newHead = head;
        head = nextNode;
    }
    return newHead;
}

private boolean isEqual(ListNode l1, ListNode l2) {
    while (l1 != null && l2 != null) {
        if (l1.val != l2.val) return false;
        l1 = l1.next;
        l2 = l2.next;
    }
    return true;
}
```



我的思路：

判断是否回文，关键在于依次比较两端的元素，并逐渐向中间移动，一个指针从起点移向中间，一个从终点移向中间。

易错点：

- 创建新的object：需要声明type,需要用new

- 数组array使用方法：创建 int[]， 获取.get()

- 其它object的元素获取方法要使用x.get()

- 比较大小要使用equals。

  



##  9. 分隔链表

725\. Split Linked List in Parts(Medium)

[Leetcode](https://leetcode.com/problems/split-linked-list-in-parts/description/) / [力扣](https://leetcode-cn.com/problems/split-linked-list-in-parts/description/)

```html
Input:
root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3
Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]
Explanation:
The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.
```

题目描述：把链表分隔成 k 部分，每部分的长度都应该尽可能相同，排在前面的长度应该大于等于后面的。

```java
public ListNode[] splitListToParts(ListNode root, int k) {
    int N = 0;
    ListNode cur = root;
    while (cur != null) {
        N++;
        cur = cur.next;
    }
    int mod = N % k;
    int size = N / k;
    ListNode[] ret = new ListNode[k];
    cur = root;  
    for (int i = 0; cur != null && i < k; i++) {
        ret[i] = cur;
        int curSize = size + (mod-- > 0 ? 1 : 0);
        for (int j = 0; j < curSize - 1; j++) {
            cur = cur.next;
        }
        ListNode next = cur.next;
        cur.next = null;
        cur = next;
    }
    return ret;
}
```

思路：

input：ListNode head， int k;

output: ListNode[] 长度为k

假设head长度为length, 商为length/k,余数为length%k。也就是每个分隔的基础数目为商，前余数个分隔的数目为商+1.



易错点：

关键：

- 首先看函数输入和输出类型，确定输入和输出是什么
- 在链表中插入元素需要插入处前面的node，所以就需要一个dummy node，注意最后得到的结果应该是dummy_node.next，删去前面的无用的那个node。
- 对链表进行修改，最后需要返回改变链表的，需要创造一个指针完成对该链表的修改。
- 先从抽象的层面思考编写代码，然后再一个一个解决任务。这样比较容易记。





##  10. 链表元素按奇偶聚集

328\. Odd Even Linked List (Medium)

[Leetcode](https://leetcode.com/problems/odd-even-linked-list/description/) / [力扣](https://leetcode-cn.com/problems/odd-even-linked-list/description/)

```html
Example:
Given 1->2->3->4->5->NULL,
return 1->3->5->2->4->NULL.
```

```java
public ListNode oddEvenList(ListNode head) {
    if (head == null) {
        return head;
    }
    ListNode odd = head, even = head.next, evenHead = even;
    while (even != null && even.next != null) {
        odd.next = odd.next.next;
        odd = odd.next;
        even.next = even.next.next;
        even = even.next;
    }
    odd.next = evenHead;
    return head;
}
```

链表元素按照奇偶聚集，奇数排在前面，偶数排在后面（奇、偶指的是index）。输出为排序好的链表。

需要奇数链表的头node， 尾node，以及偶数链表的头node。以及判断奇偶的方法。



方法1：

- 得到奇列表和偶列表
  - 不断向里面添加奇或者偶node
  - 添加node需要prev node使用next方法
  - 因此需要创建dummy node
- 判断奇偶的方法：
  - 第一个是奇
  - 奇的下一个是偶
  - 偶的下一个是奇
- 将奇列表和偶列表结合在一起， 奇列表在前， 偶列表在后。
  - 需要奇数链表的 尾node指针，以及偶数链表的头node指针。



## 11.[剑指 Offer 06. 从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)

### [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

找到链表中环的起始点，数学问题，这个有点忘记了

## 链表重排

对链表进行重排列。**不能只是单纯的改变节点内部的值**，而是需要实际的进行节点交换。题目说了交换吧，所以反对用栈啊或者双向队列重新拷贝之类的方法，应该是在原来链表上操作

不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。这句话说的意思就是不能进行拷贝，如果进行拷贝就是不对的，要保留原来的样子。（不能使用ListNode(head.val)这样的方法。

说实话有点难搞。

[21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

[23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

[82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)

[19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

[2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

[328. 奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/)

## 总结

- 指针：**当你需要对node.next进行修改的时候，就需要一个指向它的指针。**
  - **当你需要对链表进行修改的时候，同时又不想失去该链表时。需要创建一个它的指针对它进行修改，这样就不会改变它本身的地址。**
  - 多指针法：删除、调位操作，iterate需要考虑循环到中间是的情况
  - 当需要4个连续node，则需要3个node的next存在，也就是不为null
  
- 链表截取：
  - 需要指针的协助
  
- recursion：只要能够简化问题，链表很适合，think recursively

- 链表操作：
  - 只能从前往后进行（如果需要从后往前可以转化为stack）
  - 如果既需要从前往后，也需要从后往前（则可以转换为array）
  - 链表没有长度属性
  - 如果要从后往前进行，也可以使用stack
  
- 删除

  - 删除一个node，删除需要两个next，所以需要cur 和 cur.next都不为null

    如果要使用next，则不能为空指针（null）
    
  - 需要该node前面一个节点

- 添加

  - 添加一个node，需要该node，以及该node前面一个节点

- 交换

  - 交换需要最前面一个节点，先从前面节点开始交换

- 复杂问题:
  - 每次只思考一个问题，不要所有东西一起想，这样会很难受
  - 先从抽象的层面思考编写代码，然后再一个一个解决任务。这样比较容易记。
  - 先列出思路，然后一点一点补充细节

- 易错点：
  - 少打一些错别字
  - 首先看函数输入和输出类型，确定输入和输出是什么
  - 创建新的object：需要声明type,需要用new

- 熟悉相关知识
  - 熟悉stack（后进先出）的相关method，不然没法用。
  - 熟悉list（能够快速获取每一个元素），不然没法用。
  - 熟悉array的创建方法，创建时array是null。

- 使用好的创建手法：
  - `ListNode newHead = new ListNode(1), p = newHead；` 能提高运行速度
  - short hand if：`int x = l1Stack.isEmpty() ? 0 : l1Stack.pop();`  (condition) ? case True : case False;

- 位加法：
  - 加法中 sum/10是进位，需要进到下一位； sum%10是余位，就保留在这一位。

- 列表的中间是（length+1）/ 2

- 快慢指针：

  使用指针的时候一定要保证原来的对象是存在的。

  root != None

  多个用法

  快慢指针，两个一起开始向前，如果链表长度为偶数，那么得到的节点是中间靠后的那个节点

  可以通过看fast == None，来判断链表长度是否为偶数，如果fast == None，则为偶数；反之则为奇数。

  if fast：

  slow = slow.next

- ```python
  #如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点
  slow = fast = head
  while fast and fast.next:
      slow = slow.next
      fast = fast.next.next
  return slow
  # 得到中间靠前的节点
  beforeSlow = slow = fast = head
  while fast and fast.next:
      beforeSlow = slow
      slow = slow.next
      fast = fast.next.next
  return beforeSlow
  ```

- 

  





