## 理论基础

**贪心的本质是选择每一阶段的局部最优，从而达到全局最优**。

例如，有一堆钞票，你可以拿走十张，如果想达到最大的金额，你要怎么拿？

指定每次拿最大的，最终结果就是拿走最大数额的钱。

每次拿最大的就是局部最优，最后拿走最大数额的钱就是推出全局最优。



贪心算法一般分为如下四步：

- 将问题分解为若干个子问题
- 找出适合的贪心策略
- 求解每一个子问题的最优解
- 将局部最优解堆叠成全局最优解



<img src="https://inews.gtimg.com/newsapp_ls/0/14504237272/0.jiketuchuang.png" alt="image.png" title="image.png" />

<img src="https://inews.gtimg.com/newsapp_ls/0/14504248431/0.jiketuchuang.png" alt="image.png" title="image.png" />



例子： 45 jump game



[455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)

两个排序数组之间寻找对应关系

\## 先排序

​    \## 只能是固定一个，然后寻找另一个

​    \## 然后对每个小胃口的，寻找能够喂饱它的饼干。

​    \## 或者对每个大饼干，寻找能够喂饱的大胃口。



[376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)

统计波峰和波谷的数量

使用preDiff 和 curDiff来判断是否为转折点，也就是波峰或者波谷。preDiff只有咋出现转折的时候才发生变化。

**动态规划**：就类似于股票的问题，存在两个状态，状态之间可以相互变换。



[53. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)

记录连续数字的和，并不断对其进行更新，如果和为负，就把它回归到0



[55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

\## 贪心算法，每次经过一个i，就更新一次最远能够到达的cover

​    \## 用while i<=cover来保证绝对不会出界，然后每次更新完之后再来判断能否到达最后一个位置。

记忆化递归：

return dp(0)



[45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)

遍历数组，给定这一步的最大覆盖范围和下一步的最大覆盖范围，当到达当前最大覆盖范围之后需要用下一步的最大覆盖范围 替换 当前最大覆盖范围，并将步数加一，再当前覆盖范围大于等于最后时，就可以得到结果

也可以使用记忆化递归的方法



[1005. K 次取反后最大化的数组和](https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/)

\## 首先按照绝对值对nums进行排序，然后每次将绝对值最大的负数转化为正数，

​    \## 如果所有数都为正数，k还是不为0，则对绝对值最小的那个不断进行转化，直到k为0



[134. 加油站](https://leetcode-cn.com/problems/gas-station/)

暴力解法，超时：

j += 1 for循环中循环变量最后的位置时在end-1处

j % n == i 数组循环遍历中，注意真实位置和循环遍历之间的区别



​    

If you draw all the rating points on a graph, there are peaks and bottoms and apparently:

1. All the bottoms should be given 1 candy in the final result.
2. The neighbors of the bottoms should be given 1 more candy as we move from bottom point to peak point.

[860. 柠檬水找零](https://leetcode-cn.com/problems/lemonade-change/)

模拟生活中的找零操作。如果能给每一个用户找开，那就true，反之则为False。

关键：对用户list进行循环，对每个用于bills[i]，有三种可能：5， 10， 20.

给5元，则不用找；给10元，则需要找5元；给20元，则需要找15元，可以是三个5元，或者一张5元一张10元。因为5元在找零上更有用，因此先给10，再给5.

用five、ten、twenty来模拟现有的零钱数量，然后判断能否召开。



[406. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

\## 对每个人来说，只关心前面的高个子，所以降序排列就可以了

​    \## 经过身高排序后，第i个人前面的所有人都要比他高

​    \## 因此从前往后依次插入，到第i个人时，因为前面的人都比他高，所以可以直接插入到

​    \## 想要插入的位置。

​    \## 那为什么要对第二个元素按照升序排序：





[452. 用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)

 贪心算法

​    首先给出任意解：随便射一箭，穿过x个区间

​    向右移动射箭位置，同时保证现有成果，将射箭的位置移动到x个区间最靠左的那个右边界

​    因此就可以考虑贪心算法了，射箭位置一定是在最靠左的右边界处

​    将points按照区间右边界排序，最靠左的右边界处射一枪，将所有射爆的气球移开

​    然后在剩下的气球中的第一个的右边界处射一枪

​    循环往复，知道气球全部被射爆。



[435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)

和上一个题目一模一样，这里是要求删除几个之后不重叠，可以先求出最终不重叠的区间数目，然后用总区间数-不重叠，就能够得到重叠的区间数目。

而不重叠的区间数目本质上就是射几箭的问题



[56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

关键是找到每个区间的左右端点。

可以对intervals按照左端点排序，先确定左端点，然后将右端点不断进行延伸



[1288. 删除被覆盖区间](https://leetcode.cn/problems/remove-covered-intervals/)

问删除所有被覆盖的区间之后，剩下的区间数目

将区间按照start升序，end降序，这样的话只有前面的才能将后面的覆盖。

因为start升序，所以左端点一定会被前面的覆盖，剩下的就只需要看end端点能否被覆盖。此时，我们记录end的最大值，如果新end小于等于maxEnd，就认为被覆盖了。那什么时候剩下区间数目会增加，只有当新end大于maxEnd，这时候就可以更新maxEnd，并将结果加一。



[986. 区间列表的交集](https://leetcode.cn/problems/interval-list-intersections/)

得到任意两个的区间的交

两个排序集合的归并，考虑归并排序

关键是得到结果之后，i, j两个指针应该怎么移动

没可能和后面区间相交的区间应该去掉，

求两个区间的交集时，left去两个中比较大的，right取两个中较小的

之后移动right较小的那个区间，因为它不会有可能与其它区间再有交集
