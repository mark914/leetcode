## 总结

理解： 每一条枝干都是一个结果，枝干对应叶节点是其结束的地方，也就是纵向递归的终止条件，

终止条件：

- path中元素数目
- path中总和大小
- index = len(s)

确定横向遍历的选择有哪些

确定纵向递归终止的条件是什么，递归的作用是向下一层前进的同时，改变选择空间

剪枝：

有数目要求的，可以考虑通过总数来进行剪枝

有总和的可以考虑通过总和来进行剪枝

注意字符串的处理

重复元素：

可以先排序，然后再使用used列表帮助去除重复元素

对数字排序： nums.sort(), 

对字符排序： sorted(s)





注意考虑特殊情况：

数组可以用来当做字典用



回溯就是一种爆搜算法，

关键例子：

- 25道题的考试，不能连续错三道

- 有效的括号生成

- 全排列

  <img src="https://inews.gtimg.com/newsapp_ls/0/14825868231/0.jiketuchuang.png" alt="image.png" title="image.png" />





### get_children

```python
## 表示方向
 dx, dy = [1, 0, -1, 0], [0, 1, 0, -1]
for i in range(4):
	nx, ny = x + dx[i], y + dy[i]

## 八个方向
## 确定备选， 进行筛选（几个方向，是否在搜索范围，是否已经搜索过）
def get_children(cell):
    i, j = cell
    return ( (i + a, j + b)
           for a in [-1, 0, 1]
           for b in [-1, 0, 1]
           if not (a == 0 and b == 0)
           if 0 <= i + a < m
           if 0 <= j + b < n
           if is_clear((i + a, j + b))
           )

## 四个方向
def get_children(cell):
    i, j = cell
    return ( (i + a, j + b)
            # 四个方向
           for a in [-1, 0, 1]
           for b in [-1, 0, 1]
           if a == 0 or b == 0
           if not (a == 0 and b == 0)
            #在搜索范围内
           if 0 <= i + a < m
           if 0 <= j + b < n
           # 是否已经搜索过
            if is_clear((i + a, i + b))
           )


## 注意分清楚i和j， 还有m和n
## 使用邻接矩阵
def get_children(i):
            return (j for j in range(n) 
                if isConnected[i][j] == 1
                if not visited[j])
        
```

总结：



###### [77. 组合](https://leetcode-cn.com/problems/combinations/)

给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

<img src="https://inews.gtimg.com/newsapp_ls/0/14521055302/0.jiketuchuang.png" alt="image.png" title="image.png" />

是一个组合问题，要注意从左往右去，取过的不再重复取

关键：

- 从左往右取，取过的不能再重复取。startIndex，每一层和每一枝干都不能重复使用
- 终止条件（什么时候到达叶子节点）k == len(path)
- 单层搜索的过程：for循环横向遍历，给出本层的所有选择；递归纵向遍历，决定下一个的参数。
- 优化，确保从startIndex开始能够有得到长度为k的结果， startIndex最大只能取n - (k-len(path)) + 1
- combination.copy()，因为combination一直是在改变的，所以需要对它进行浅复制
- 到叶子结点记得return，因为它实际上属于是N叉树的深度优先遍历

参数： n, k, startIndex, res, combination,

思路：递归的深度决定了组合的长度，可以用k来限制，为防止重复取，设置startIndex，从左往右走。然后在叶子节点得到结果



###### [216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)

找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

性质：是一个同一集合求组合的问题

res, combination, curSum, n, k, startIndex 。

参数：startIndex, curSum

 其中curSum 和 combination是一直在改变的，这种情况下如果是list则没事，因为它是mutable；curSum为int，不是mutable，因此就需要将之添加到参数中。

关键：

- 从左往右，每一层不能重复使用，每一枝干也不能重复使用
- 终止条件：cursum > n ， k == len(combination) and curSum == n，对组合总和与组合数目都有要求，到叶子节点需要return
- 单层搜索：添加一个数字到组合里，可选择的有1:9，因此前面取过的后面不能再取，所以startIndex。因为同一层不能重复取，所有dfs(i + 1)。
- 优化：curSum + i >n就不用进入递归 ， k的大小也可以优化

思路：同一集合中取数量一定的子集，使得他们的和一定，两个限制条件。只有都满足的时候才能加入到res中。



###### [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

性质：是一个不同集合求组合的问题

res, path, index, 

参数： index ，每层递归解决一个占位问题，

关键：

- index控制每层做什么
- 终止条件： index == len(digits)，也就是字母长度达到要求了
- 单层搜索：添加一个字符到path，结果是“”.join(path)
- 考虑特殊情况，当len(digits) == 0时，结果为[]
- dfs是在遍历，修改结果

思路： 遍历每个index，得到index对应的letters，然后每层添加并删除letter，因此不能重复取，所以dfs(index + 1)，index == len(digits)



先在大脑中想出解决问题的 树状图， 找出每一层解决的子问题，每层递归解决一个问题

###### [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

性质：是一个在总和一定的情况下求组合的问题，组合数量不限定，每个元素可以用无限次

参数：startIndex， res,  path, total, 



关键：

- 每一层不能重复使用，每个枝干可以重复使用
- 枝干上重复是指位置的重复，层上的重复是指数值上的重复。
- 对total的限制和优化
- 终止条件：当total == target， 后面要加上return
- dfs是在遍历，修改结果

思路：用组合的总和来控制递归的深度。

每层递归做的事情，就是子问题，子问题的dec_space会发生改变

优化剪枝，在进入下一层递归之前，排除其可能性

###### [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

相同的数，只取第一个就好了，后面的都可以不取， 因为排过序，了，所以要求i > startIndex 就可以了。

每一层不能重复使用，数值和位置上都不可以。



###### [131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

-  每次递归的任务： 寻找一个符合要求的分割位置， 如何对str进行分割，如何判断分割是回文的。 # 如何对str进行分割： 确定分割起点和终点 s[start, end+1]
- 如何判断分割是否回文：temp = s[start:end+1] temp == temp[::-1]
- 下一次递归要从下一个分割位置开始。

性质： 是一个求所有字符串所能得到的组合问题，组合的长度不确定，startIndex到第就可以了

参数：res, path, start, end

关键：

对字符串进行分割，每次分割的位置为startIndex，如果分割得到的字符串不是回文的就跳过。一定是有解的，因为一个字母就是回文的。



###### [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

对字符串的处理：可以使用s[:i] + s[i:]；也可以使用列表， ".".join(path)，然后将列表拼接成字符串，用列表这个更好

性质：分割字符串，是一个组合问题，将字符串分割为4个部分，每个部分都要是有效的。

参数：res, path, startIndex, start, end

关键：

- 终止条件：字符串被分割为4部分，len(path) == 4 and startIndex == len(s) ，或者len(path) > 4，这是就需要进行剪枝。 同一层上，如果有一个分割的字符串不是有效的，那后面的一定都不是有效的。

思路：对字符串进行分割，分割为4部分，每部分都是有效的，是一个组合问题。非常的简单

###### [78. 子集](https://leetcode-cn.com/problems/subsets/)

将所有地方的都加到结果里

性质：求子集，没有重复元素，是求组合问题，每个节点处都要添加一次。

参数：res, subset, startIndex,

关键：每个节点都要添加一次结果。

###### [90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)

包含重复元素的子集

- 在每一层上不能重复用，但是在每一条枝干上可以重复用
- 因为枝干是纵向的，由递归控制，而递归dfs(i + 1)会自动排除和前面的i比较
- 而层是横向的，因此就能够和前面的进行比较。

有重复元素，因为重复元素的子集的互相包含的，因此我们只取第一个重复元素对应的子集就可以了。要跳过后面的重复的元素。

性质：求子集，存在重复元素，是求组合问题，每个节点处都要添加一次。有重复元素的求子集问题

参数：res, subset, startIndex, 

关键：

同一层上不能使用值相同的元素。可以使用 used ,也可以使用set，也可以不适用这两个，总共三种方法。这三种方法在去重的时候都需要排序

问题： 不知道为什么这里使用set对同一层去重，也需要用到排序。

###### [491. 递增子序列](https://leetcode-cn.com/problems/increasing-subsequences/)

含有重复元素，使用uset去重，不能排序，

性质：求子集，存在重复元素，是求满足一定条件的组合问题。每个len(path) > 2的地方都需要更新一下结果。

参数：res, path, startIndex, 

关键：

- 寻找下一个元素的时候一定要它大于上一个元素，nums[i] >= path[-1]， 使用path索引的时候，一定要保证里面有元素
- 同一层不能使用同值元素



###### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

- 在每一枝干上不能有重复使用的
- 因为没有重复元素，所以在没一层上是不会出现重复元素的
- 如果数组中存在重复元素，那就要考虑如何去掉重复元素，可以用之前的used
- 如果和前面的相同，而且前面的没用，说明这是在同一层，同一层不能使用
- 相同值的元素，那就需要continue

性质：不含重复元素的全排列问题。

参数: res, path, used,

因为后面还会使用到前面的，所有不能使用startIndex。

关键点：

- 同一层上因为nums中无重复元素 ，for循环从前往后，因此不用担心出现重复元素。但是同一枝干上就需要担心，同一位置上的元素被重复使用。因此每次for循环都是从头开始的。
- 在枝干上进行的就需要先加，之后再减去。

思路：只要求同一枝干上不能使用同一位置上的元素，这样深度向下，能使用的元素会逐渐减少。直到没有元素可以使用，到达叶结点，然后更新结果。

###### [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

含有重复元素

性质：含有重复元素的全排列问题

参数：res, path, used

关键：

- ​	同一层不可以用，同一枝干可以用
- ​    在同一枝干上，位置不同则不相同
- ​    在同一层上，值相同就相同，不管位置是否相同





有一个关键点：使用set去重的时候也需要排序。在子集问题中是这样的，最长递增序列则不需要。



###### [51. N 皇后](https://leetcode-cn.com/problems/n-queens/)

性质：列出所有可能的情况，路径中存在限制

参数：row

子问题： 每次向第row行防止一个皇后，看能否放下去，如果不能放下去，那么这个路径就被丢弃。

每次可以做的选择：所有列都可以

做选择时候的限制：上下和对角线上不能出现皇后，在同一对角线上：正对角线满足（i - j  = row - col), 副对角线满足：（i + j = row + col)





###### [698. 划分为k个相等的子集](https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/)

性质：给定一个整数数组nums和一个正整数k，判断是否能够把这个数组分为k个非空子集，其总和都是相等的。

思路：找出所有



###### [37. 解数独](https://leetcode-cn.com/problems/sudoku-solver/)

性质：**对每一个空着的格子穷举 1 到 9，如果遇到不合法的数字（在同一行或同一列或同一个 3×3 的区域中存在相同的数字）则跳过，如果找到一个合法的数字，则继续穷举下一个空格子**。

关键：如何通过递归来遍历二维数组， 如何遍历一个小的3*3的小格子，如果找到一个可行解之后，就立即返回。

###### [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

性质：采用递归回溯的方法来解决这个问题

对结果的约束：

 **1、一个「合法」括号组合的左括号数量一定等于右括号数量，这个很好理解**。

**2、对于一个「合法」的括号字符串组合 `p`，必然对于任何 `0 <= i < len(p)` 都有：子串 `p[0..i]` 中左括号的数量都大于或等于右括号的数量**。

left，right两个变量，现在有 `2n` 个位置，每个位置可以放置字符 `(` 或者 `)`，组成的所有括号组合中，有多少个是合法的？

[698. 划分为k个相等的子集](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/)

方法一： 对每个val放到k的bucket中，因此时间复杂度为O(k**n)。

![image-20220520104937928](C:\Users\Mrcao\AppData\Roaming\Typora\typora-user-images\image-20220520104937928.png)



方法二：从nums中找到何为target的子集， 直到创建了k个这样的子集。时间复杂度为O(k*2**n)

![image-20220520105437306](C:\Users\Mrcao\AppData\Roaming\Typora\typora-user-images\image-20220520105437306.png)

Correction: The time complexity of the 2nd solution is actually O(2^ (k*n)), because if we have K trees stacked on top of each other, the new height of the tree is K * n.





总结：

回溯能够尝试所有可能性，解决给出所有排列组合的问题，可能会对排列组合施加约束，这就需要看结果是否符合约束条件。

思考：dfs每一层递归是在干啥，然后每次递归的时候有哪些选择，dfs(**arg)中的参数有可能会影响到path中添加记录的选择。

比如：

- 全排列中 dfs(n)每一层在确定排列的第n位上的数，因此当n == len(nums)时，就说明排列已经完全确定了。全排列中的选择有len(nums)个，但是会受到之前已经做出选择的影响，也就是之前用过的就不能用了，因此就需要使用used数组来进行标记，对dfs中的选择进行限制。
- 括号生成中，dfs(n)每一层在确定生成括号第n位上的值，因此当左右单侧括号都用完的时候，递归就结束了。括号生成中的选择有两种，但是会受到有效括号的影响，因此需要排除非有效括号的情况。

回溯和搜索之间的区别：

回溯和dfs等之间的区别在于对根节点的处理。在搜索的时候是要包括根节点的，因此path.append(), path.pop()都是在for循环外面的，而回溯中则主要是对枝干的处理，因此是在for循环里面的。

对于搜索遍历来说：

算法会打印出所有结点的结果

```python
def traverse(root):
    """
    root: TreeNode
    """
    if not root: return
    print("enter:" + root.val)
    for child in root.children:
        traverse(child)
	print("leave:" + root.val)
```

对于回溯算法来说：

涉及到的其实是 递归和选择，主要是对枝干的处理。

```python
def traverse(root):
    """
    root: TreeNode
    """
    if not root: return
    for child in root.children:
    	print("enter:" + root.val)
        traverse(child)
		print("leave:" + root.val)
```

