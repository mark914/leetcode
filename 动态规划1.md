 动态规划中其实使用了递归的思想，因为我们在使用状态转移方程的时候，**其实是假设之前的状态时已知的**，**然后根据边界条件和状态转移方程一步一步递推到最终的结果。**

这其实就是递归的思想了，因为我们假设了边界条件，并且也有不断简化问题的方法（条件转移方程），最终所有问题都转化为最简单的条件。**只不过再动态规划中，我们使用array dp记下来不同状态的结果。从而减少了时间复杂度。**也即在递归的基础上 用空间换时间。



关键：

\## 每个状态对应的意思是什么， 你最重要求得是什么

​    \## 状态之间是如何转化的

​    \## 边界条件是什么

- dp数组以及下标的含义. dp[i]， **每个转态的意思是什么**， 最后要求的是哪个状态
- 递推公式， **转态之间是如何转换的**
- 边界条件，dp数组如何初始化，dp数组开头**应该初始化为多少**，不同情况分开考虑
- 遍历顺序，0-1背包问题中有两层遍历（先遍历背包，再遍历物品）**排列组合**
- 打印dp数组（用来debug）
- 注意是index，还是说前i个

面试问题其实不是很难，但是非常考察本质性的问题。





0-1背包问题：



N件物品， w和v

capacity W

价值最大化，每件物体只能使用0或1次

计算理论：NP问题（Nondeterministic Polynomially）







DP： Dynamic programming

When to use dp?

Counting

Optimization





fib题解：

记忆化递归和DP之间的区别

记忆化递归：

自顶向下，将问题不断分解，直到base case最简单的情况，然后再向上回溯，最终得到结果。

- 记忆化递归中没有循环，并提前设置好了边界条件
- 递归中有几个变量，你就可以省去几个循环
- 递归中则不太关心是否已经求解过，没求过就把问题继续分解。所以递归是从上到下，然后在从下到上。
- 记录递归call的栈可能会爆掉
- 不能够降维

DP

自底向上，从最简单的情况出发（base case）往上推，直到推到我们想要的答案。

- DP中有一个循环，需要提前填充初始化边界条件。
- DP中需要注意你要用的状态一定要提前求结果，所以DP是down2top
- 可以降维

<img src="https://dd-static.jd.com/ddimg/jfs/t1/198505/26/11602/212694/615c09b3Ef9ef244f/0cec259966e9922c.png" alt="image.png" title="image.png" />

记忆化递归将之转化为m*n个子问题，所以时间复杂度为O(N)

<img src="https://dd-static.jd.com/ddimg/jfs/t1/198162/9/11542/231802/615c0c28E6ee54ada/04a917053a2ac78c.png" alt="image.png" title="image.png" />











## ＯＣＷ：

### ｍｉｔ：　ａ　ｉｎｔｒｏｄｕｃｔｉｏｎ　ｔｏ　ａｌｇｏｒｉｔｈｍ

#### ｄｙｎａｍｉｃ　ｐｒｏｇｒａｍｍｉｎｇ：

<img src="https://inews.gtimg.com/newsapp_ls/0/14486648361/0.jiketuchuang.png" alt="image.png" title="image.png" />





​	



###### [718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)

- 重复子数组， 以下标i - 1为结尾的A子数组，和以下标j - 1为结尾的B子数组，最长重复子数组长度为$dp[i][j]$.
- 初始值设为0，只在特定条件下变为非0，有改变子数组起始位置的作用。

由递推公式可知，所有的都是从$dp[0][0]$推出来的，

```python
res = 0
if nums1[i-1] == nums2[j-1]:
    dp[i][j] = dp[i-1][j-1] + 1
res = max(dp[i][j], res)
```

[1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

最长公共子序列， 长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为$dp[i][j]$。

得到最长公共子序列

https://www.nowcoder.com/questionTerminal/6d29638c85bb4ffd80c020fe244baf11

```python
if text1[i-1] == text2[j-1]:
    dp[i][j] = dp[i-1][j-1] + 1
else:
    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
```

最长递增子序列

输出零钱兑换的具体方案

输出装入背包的方案

$dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i-1]]+v[i-1])$





###### [1035. 不相交的线](https://leetcode-cn.com/problems/uncrossed-lines/)

最长公共子序列， 长度为[0, i - 1]的数组nums1与长度为[0, j - 1]的数组nums2的最长公共子序列为$dp[i][j]$。



###### [53. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)

方法一： 贪心算法

- ans初始化应该为 float('-inf)

方法二：动态规划

- **包括下标i之前的最大连续子序列和为dp[i]**

  ```python
  dp[i] = max(dp[i-1] + nums[i], nums[i])
  ```

###### [392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)

- 判断s是否为t的子序列，也就是s是连续的，t要删除一些东西才能得到s。
- **$dp[i][j]$ 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为$dp[i][j]$**。

```python
if s[i-1] == t[j-1]:
    dp[i][j] = dp[i - 1][j - 1] + 1
else:
    dp[i][j] = dp[i][j - 1]
```

###### [115. 不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/)

以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为$dp[i][j]$。

给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。 	

```python
if s[i-1] == t[j-1]:
    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
else:
    dp[i][j] = dp[i-1][j]
```

###### [583. 两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)

- $dp[i][j]$以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。
- 给定两个单词 `word1` 和 `word2` ，返回使得 `word1` 和 `word2` **相同**所需的**最小步数**。

```python
if word1[i-1] == word2[j-1]:
    dp[i][j] = dp[i-1][j-1]
else:
    dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1)
```

###### [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

- 给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。
- **以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为$dp[i][j]$**。

```python
if word1[i - 1] == word2[j - 1]:
   dp[i][j] = dp[i - 1][j - 1]
else:
   dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1 
```



###### [647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

更适合用双指针的方法解决

###### [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

和上一题一模一样



##### [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

只完成一笔交易

$dp[i][0] = max(dp[i - 1][0], -prices[i])$

 $dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0])$

##### [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

可以完成任意次交易

```python
dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]); // 注意这里是和121. 买卖股票的最佳时机唯一不同的地方。
dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
```

##### [123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

最多可以完成 两笔 交易

```python
dp[i][0] = dp[i - 1][0];
dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
```

##### [188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

你最多可以完成 **k** 笔交易

长度为2*k+1的结果。

```python
for (int j = 0; j < 2 * k - 1; j += 2) {
    dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
    dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
}
```



![image-20220806213019295](C:\Users\Mrcao\AppData\Roaming\Typora\typora-user-images\image-20220806213019295.png)

如何区别搜索和动态规划，

什么时候为动态规划？

从初始状态开始，是一个有向无环图，有环不是动态规划，数据量太大也不一定是动态规划。 

状态数*状态转移的时间消耗 < 10^6

青蛙跳台阶：

mod， 状态转移，初始状态，

爬楼梯：

和上一题相同

1342，数字变为0的次数

分情况递归，主要是自底向上的思路

剑指 88 爬楼梯最小花费（746）

f(i) 表示爬到第i层的最小花费

### 线性DP

#### O(1)状态转移

198.打家劫舍

dp[i]表示抢下标i前（包括i）的所有房子，能够得到的最大值



打家劫舍II

其实不太会



91解码方法

自底向上，求方案数，累加，所有结果都是从初始位置得到的，因为初始位置应该是有值的。

dp  = [0] * (len(nums) + 1) 是为了后面求解方便

dp[i] = dp[i-1] + dp[i-2],必须需要前面两个结果，但如果n <= 2,那就没有两个结果，因此保证i-2是有意义的，所以dp = [0] * (len(nums) + 1) 



1646 获取生成数组中的最大值



1043 分隔数组以获得最大和

确定状态很重要

dp[i]表示以i为结尾的数组最大和， 因为数组最大和是可以分隔累加的，因为可以这样做。



139 单词拆分

这里将

n = len(s)

dp = [False] * (n+1)

这里要注意下标表示的是前i个，前i-j到前i个之间s[i-j+1, i]





