# Leetcode é¢˜è§£ - æ ‘
<!-- GFM-TOC -->

* [Leetcode é¢˜è§£ - æ ‘](#leetcode-é¢˜è§£---æ ‘)
    * [é€’å½’](#é€’å½’)
        * [1. æ ‘çš„é«˜åº¦](#1-æ ‘çš„é«˜åº¦) maxï¼ˆæ¯ä¸ªç»“ç‚¹å·¦å³treeçš„æ·±åº¦ï¼‰+ 1
        * [2. å¹³è¡¡æ ‘ ](#2-å¹³è¡¡æ ‘)  æ¯ä¸ªç»“ç‚¹çš„å·¦å³treeçš„æ·±åº¦å·® <= 1
        * [3. ä¸¤èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„](#3-ä¸¤èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„) ç»“ç‚¹å·¦å³tree çš„æ·±åº¦å’Œ + ä¸€åˆ—æ•°é‡Œé¢çš„æœ€å¤§å€¼
        * [4. ç¿»è½¬æ ‘](#4-ç¿»è½¬æ ‘) ä¸¤å…ƒç´ äº’æ¢
        * [5. å½’å¹¶ä¸¤æ£µæ ‘](#5-å½’å¹¶ä¸¤æ£µæ ‘) å½’å¹¶ + å·¦å³æ ‘åˆ†åˆ«å½’å¹¶
        * [6. åˆ¤æ–­è·¯å¾„å’Œæ˜¯å¦ç­‰äºä¸€ä¸ªæ•°](#6-åˆ¤æ–­è·¯å¾„å’Œæ˜¯å¦ç­‰äºä¸€ä¸ªæ•°) rootèµ·å§‹ï¼Œå¶èŠ‚ç‚¹ç»“å°¾ + å·¦å³å­æ ‘è·¯å¾„å’Œä¸ºä¸€ä¸ªnum
        * [7. ç»Ÿè®¡è·¯å¾„å’Œç­‰äºä¸€ä¸ªæ•°çš„è·¯å¾„æ•°é‡ ](#7-ç»Ÿè®¡è·¯å¾„å’Œç­‰äºä¸€ä¸ªæ•°çš„è·¯å¾„æ•°é‡) å¯ä»¥åŒ…å«rootï¼Œå¯ä»¥ä¸åŒ…å«rootï¼Œä¸éœ€è¦leafç»“å°¾ + ç´¯åŠ 
        * [8. å­æ ‘](#8-å­æ ‘) ä¸¤treeç›¸åŒ + å‰åºéå†
        * [9. æ ‘çš„å¯¹ç§°](#9-æ ‘çš„å¯¹ç§°) å·¦å³tree æ˜¯å¦å¯¹ç§° 
        * [10. æœ€å°è·¯å¾„](#10-æœ€å°è·¯å¾„) rootèµ·å§‹ï¼Œå¶èŠ‚ç‚¹ç»“å°¾ + å·¦å³æ ‘æ·±åº¦ä¸­æœ€å°çš„
        * [11. ç»Ÿè®¡å·¦å¶å­èŠ‚ç‚¹çš„å’Œ](#11-ç»Ÿè®¡å·¦å¶å­èŠ‚ç‚¹çš„å’Œ) å·¦å¶èŠ‚ç‚¹ + å­æ ‘çš„å·¦å¶èŠ‚ç‚¹ + ç´¯åŠ 
        * [12. ç›¸åŒèŠ‚ç‚¹å€¼çš„æœ€å¤§è·¯å¾„é•¿åº¦](#12-ç›¸åŒèŠ‚ç‚¹å€¼çš„æœ€å¤§è·¯å¾„é•¿åº¦)
        * [13. é—´éš”éå†](#13-é—´éš”éå†)
        * [14. æ‰¾å‡ºäºŒå‰æ ‘ä¸­ç¬¬äºŒå°çš„èŠ‚ç‚¹](#14-æ‰¾å‡ºäºŒå‰æ ‘ä¸­ç¬¬äºŒå°çš„èŠ‚ç‚¹)
    * [å±‚æ¬¡éå†](#å±‚æ¬¡éå†)
        * [1. ä¸€æ£µæ ‘æ¯å±‚èŠ‚ç‚¹çš„å¹³å‡æ•°](#1-ä¸€æ£µæ ‘æ¯å±‚èŠ‚ç‚¹çš„å¹³å‡æ•°)
        * [2. å¾—åˆ°å·¦ä¸‹è§’çš„èŠ‚ç‚¹](#2-å¾—åˆ°å·¦ä¸‹è§’çš„èŠ‚ç‚¹)
    * [å‰ä¸­ååºéå†](#å‰ä¸­ååºéå†)
        * [1. éé€’å½’å®ç°äºŒå‰æ ‘çš„å‰åºéå†](#1-éé€’å½’å®ç°äºŒå‰æ ‘çš„å‰åºéå†)
        * [2. éé€’å½’å®ç°äºŒå‰æ ‘çš„ååºéå†](#2-éé€’å½’å®ç°äºŒå‰æ ‘çš„ååºéå†)
        * [3. éé€’å½’å®ç°äºŒå‰æ ‘çš„ä¸­åºéå†](#3-éé€’å½’å®ç°äºŒå‰æ ‘çš„ä¸­åºéå†)
    * [BST](#bst)
        * [1. ä¿®å‰ªäºŒå‰æŸ¥æ‰¾æ ‘](#1-ä¿®å‰ªäºŒå‰æŸ¥æ‰¾æ ‘)
        * [2. å¯»æ‰¾äºŒå‰æŸ¥æ‰¾æ ‘çš„ç¬¬ k ä¸ªå…ƒç´ ](#2-å¯»æ‰¾äºŒå‰æŸ¥æ‰¾æ ‘çš„ç¬¬-k-ä¸ªå…ƒç´ )
        * [3. æŠŠäºŒå‰æŸ¥æ‰¾æ ‘æ¯ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½åŠ ä¸Šæ¯”å®ƒå¤§çš„èŠ‚ç‚¹çš„å€¼](#3-æŠŠäºŒå‰æŸ¥æ‰¾æ ‘æ¯ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½åŠ ä¸Šæ¯”å®ƒå¤§çš„èŠ‚ç‚¹çš„å€¼)
        * [4. äºŒå‰æŸ¥æ‰¾æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ](#4-äºŒå‰æŸ¥æ‰¾æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ)
        * [5. äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ](#5-äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ)
        * [6. ä»æœ‰åºæ•°ç»„ä¸­æ„é€ äºŒå‰æŸ¥æ‰¾æ ‘](#6-ä»æœ‰åºæ•°ç»„ä¸­æ„é€ äºŒå‰æŸ¥æ‰¾æ ‘)
        * [7. æ ¹æ®æœ‰åºé“¾è¡¨æ„é€ å¹³è¡¡çš„äºŒå‰æŸ¥æ‰¾æ ‘](#7-æ ¹æ®æœ‰åºé“¾è¡¨æ„é€ å¹³è¡¡çš„äºŒå‰æŸ¥æ‰¾æ ‘)
        * [8. åœ¨äºŒå‰æŸ¥æ‰¾æ ‘ä¸­å¯»æ‰¾ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œä½¿å®ƒä»¬çš„å’Œä¸ºä¸€ä¸ªç»™å®šå€¼](#8-åœ¨äºŒå‰æŸ¥æ‰¾æ ‘ä¸­å¯»æ‰¾ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œä½¿å®ƒä»¬çš„å’Œä¸ºä¸€ä¸ªç»™å®šå€¼)
        * [9. åœ¨äºŒå‰æŸ¥æ‰¾æ ‘ä¸­æŸ¥æ‰¾ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹å·®çš„æœ€å°ç»å¯¹å€¼](#9-åœ¨äºŒå‰æŸ¥æ‰¾æ ‘ä¸­æŸ¥æ‰¾ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹å·®çš„æœ€å°ç»å¯¹å€¼)
        * [10. å¯»æ‰¾äºŒå‰æŸ¥æ‰¾æ ‘ä¸­å‡ºç°æ¬¡æ•°æœ€å¤šçš„å€¼](#10-å¯»æ‰¾äºŒå‰æŸ¥æ‰¾æ ‘ä¸­å‡ºç°æ¬¡æ•°æœ€å¤šçš„å€¼)
    * [Trie](#trie)
        * [1. å®ç°ä¸€ä¸ª Trie](#1-å®ç°ä¸€ä¸ª-trie)
        * [2. å®ç°ä¸€ä¸ª Trieï¼Œç”¨æ¥æ±‚å‰ç¼€å’Œ](#2-å®ç°ä¸€ä¸ª-trieï¼Œç”¨æ¥æ±‚å‰ç¼€å’Œ)
        <!-- GFM-TOC -->


## é€’å½’

ä¸€æ£µæ ‘è¦ä¹ˆæ˜¯ç©ºæ ‘ï¼Œè¦ä¹ˆæœ‰ä¸¤ä¸ªæŒ‡é’ˆï¼Œæ¯ä¸ªæŒ‡é’ˆæŒ‡å‘ä¸€æ£µæ ‘ã€‚æ ‘æ˜¯ä¸€ç§é€’å½’ç»“æ„ï¼Œå¾ˆå¤šæ ‘çš„é—®é¢˜å¯ä»¥ä½¿ç”¨é€’å½’æ¥å¤„ç†ã€‚

###   1. æ ‘çš„é«˜åº¦

104\. Maximum Depth of Binary Tree (Easy)

[Leetcode](https://leetcode.com/problems/maximum-depth-of-binary-tree/description/) / [åŠ›æ‰£](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/description/)

æ€è·¯ï¼šä½¿ç”¨é€’å½’çš„æ–¹æ³•è§£å†³è¯¥é—®é¢˜

base case: root = null åˆ™depth = 1ï¼›

recursionï¼šmaxDepth  ä¸ºmax(leftDepth, rightDepth) + 1.å·¦å³ä¸¤è¾¹çš„æ·±åº¦ + 1ï¼›

æ€»ç»“ï¼š

recursionä¸€å®šè¦æœ‰ç®€åŒ–ï¼Œè®©é—®é¢˜å˜å¾—è¶Šæ¥è¶Šç®€å•

think recursivelyï¼Œ æƒ³è±¡è¯¥æ–¹æ³•èƒ½å¤Ÿè§£å†³è¯¥é—®é¢˜ã€‚

```java
public int maxDepth(TreeNode root) {
    if (root == null) return 0;
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}
```





### 2. å¹³è¡¡æ ‘

110\. Balanced Binary Tree (Easy)

[Leetcode](https://leetcode.com/problems/balanced-binary-tree/description/) / [åŠ›æ‰£](https://leetcode-cn.com/problems/balanced-binary-tree/description/)

```html
    3
   / \
  9  20
    /  \
   15   7
```

å¹³è¡¡æ ‘å·¦å³å­æ ‘é«˜åº¦å·®éƒ½å°äºç­‰äº 1

æ€è·¯ï¼š

å¹³è¡¡ä¸å¦å…³é”®åœ¨äºå·¦å³ä¸¤ææ·±åº¦ç›¸å·®å¤šå°‘ï¼Œä¹Ÿå°±éœ€è¦è®¡ç®—å·¦å³ä¸¤æå¹²çš„æ·±åº¦ã€‚åœ¨è®¡ç®—treeæ·±åº¦çš„æ—¶å€™ï¼Œå°±æ˜¯ç”¨äº†é€’å½’ï¼Œæ˜¯ä»åº•å‘ä¸Šè®¡ç®—çš„ï¼Œæ¯ä¸€ä¸ªç»“ç‚¹åªéœ€è¦è®¡ç®—ä¸€æ¬¡æ·±åº¦ã€‚è¿™æ ·æ—¶é—´å¤æ‚åº¦ä¸ºO(n)ã€‚

ç›¸å½“äºæ˜¯åå‘éå†ã€‚

```java
private boolean result = true;

public boolean isBalanced(TreeNode root) {
    maxDepth(root);
    return result;
}

public int maxDepth(TreeNode root) {
    if (root == null) return 0;
    int l = maxDepth(root.left);
    int r = maxDepth(root.right);
    if (Math.abs(l - r) > 1) result = false;
    return 1 + Math.max(l, r);
}
```

- å¾—åˆ°æ¯ä¸ªç»“ç‚¹å·¦å³ä¸¤æå¹²leftï¼Œrightçš„æ·±åº¦
- åªè¦abs(left-right) > 1,åˆ™ä¸å¹³è¡¡
- å› æ­¤ä½¿ç”¨instance variable **ret**ï¼Œ maxDepthå¯¹ ret è¿›è¡Œä¿®æ”¹
- è®¡ç®—æ·±åº¦æ—¶ï¼Œæ˜¯æŒ‰ç…§èŠ‚ç‚¹ä¸ªæ•°æ¥è®¡ç®—çš„

### 3. ä¸¤èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„

543\. Diameter of Binary Tree (Easy)

[Leetcode](https://leetcode.com/problems/diameter-of-binary-tree/description/) / [åŠ›æ‰£](https://leetcode-cn.com/problems/diameter-of-binary-tree/description/)

```html
Input:

         1
        / \
       2  3
      / \
     4   5

Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].
```

æ€è·¯ï¼š

æƒ³è¦çŸ¥é“æœ€é•¿é€šè·¯ï¼Œéœ€è¦çŸ¥é“å·¦å³ä¸¤è¾¹çš„é•¿åº¦ï¼Œå·¦å³ä¸¤è¾¹çš„é•¿åº¦ä¹‹å’Œå³ä¸ºæœ€é•¿è·ç¦»ã€‚ è€Œæˆ‘ä»¬åœ¨è®¡ç®—æœ€æ·±æ·±åº¦çš„æ—¶å€™å°±ç®—è¿‡æ¯ä¸ªæçš„æ·±åº¦ï¼Œè¿™å°±å¯ä»¥åˆ©ç”¨èµ·æ¥ã€‚

```java
private int max = 0;

public int diameterOfBinaryTree(TreeNode root) {
    depth(root);
    return max;
}

private int depth(TreeNode root) {
    if (root == null) return 0;
    int leftDepth = depth(root.left);
    int rightDepth = depth(root.right);
    max = Math.max(max, leftDepth + rightDepth);
    return Math.max(leftDepth, rightDepth) + 1;
}
```

- è®¡ç®—æœ€é•¿é€šè·¯æ—¶ï¼Œæ˜¯æŒ‰ç…§è¿çº¿ä¸ªæ•°æ¥è®¡ç®—çš„
- æœ€é•¿é€šè·¯å°±æ˜¯æ¯ä¸ªèŠ‚ç‚¹çš„right+left çš„æœ€å¤§å€¼ï¼Œæ±‚ä¸€åˆ—æ•°æœ€å¤§å€¼çš„æ–¹æ³•
- å¯¹æ¯ä¸ªèŠ‚ç‚¹çš„left|rightè¿›è¡Œå¤„ç†ï¼Œæ±‚maxDepthæœ€éœ€è¦ã€‚

### 4. ç¿»è½¬æ ‘

226\. Invert Binary Tree (Easy

[Leetcode](https://leetcode.com/problems/invert-binary-tree/description/) / [åŠ›æ‰£](https://leetcode-cn.com/problems/invert-binary-tree/description/)

æ€è·¯ï¼š

ä½¿ç”¨é€’å½’æ–¹æ³•ï¼š

ä»åº•å‘ä¸Šç¿»è½¬æ ‘ï¼Œå…³é”®åœ¨äºé€’å½’æ€ç»´ï¼Œç›¸ä¿¡methodèƒ½å¤Ÿåšåˆ°ç¿»è½¬ã€‚



```java
public TreeNode invertTree(TreeNode root) {
    if (root == null) return null;
    TreeNode left = root.left;  // åé¢çš„æ“ä½œä¼šæ”¹å˜ left æŒ‡é’ˆï¼Œå› æ­¤å…ˆä¿å­˜ä¸‹æ¥
    root.left = invertTree(root.right);
    root.right = invertTree(left);
    return root;
}
```

- ä½¿ç”¨recursion. 
  - base case  ä¸ºroot == null
- äº¤æ¢ä¸¤ä¸ªå…ƒç´ çš„å¤§å°ï¼Œéœ€è¦ç¬¬ä¸‰ä¸ªå…ƒç´ çš„å‚ä¸ã€‚

### 5. å½’å¹¶ä¸¤æ£µæ ‘

617\. Merge Two Binary Trees (Easy)

[Leetcode](https://leetcode.com/problems/merge-two-binary-trees/description/) / [åŠ›æ‰£](https://leetcode-cn.com/problems/merge-two-binary-trees/description/)

```html
Input:
       Tree 1                     Tree 2
          1                         2
         / \                       / \
        3   2                     1   3
       /                           \   \
      5                             4   7

Output:
         3
        / \
       4   5
      / \   \
     5   4   7
```

æ€è·¯ï¼š

think recursively.

- å¦‚æœæœ‰ä¸€ä¸ªæ ‘ä¸ºnullï¼Œé‚£ä¹ˆå°±å¯ä»¥ç›´æ¥è¿”å›å¦ä¸€ä¸ªæ ‘ã€‚
- å¦‚æœä¸¤ä¸ªéƒ½énullï¼Œé‚£ä¹ˆå°±å­˜åœ¨å·¦å³æå¹²ï¼Œé¦–å…ˆæœ€ä¸Šé¢çš„nodeç›¸åŠ ï¼Œç„¶åå¯¹å·¦å³æå¹²åˆ†åˆ«è¿›è¡Œç›¸åŠ ã€‚è¿”å›æ–°çš„ç›¸åŠ åçš„æ ‘ã€‚

æ˜“é”™ç‚¹ï¼š

æ–°å»ºä¸€ä¸ªobject, éœ€è¦ä½¿ç”¨newã€‚

```java
public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
    if (t1 == null) return t2;
    if (t2 == null) return t1;
    TreeNode root = new TreeNode(t1.val + t2.val);
    root.left = mergeTrees(t1.left, t2.left);
    root.right = mergeTrees(t1.right, t2.right);
    return root;
}
```

å½’å¹¶ä¸¤ä¸ªobjectçš„æ–¹æ³•æ˜¯ï¼Œä¸€ä¸ªnullåˆ™è¿”å›å¦ä¸€ä¸ª

recursionï¼Œæ¯æ¬¡è§£å†³ä¸€å°éƒ¨åˆ†ã€‚

é€’å½’çš„æ—¶å€™ï¼Œè¦è€ƒè™‘åˆ°åº•æ˜¯å¦‚ä½•é€’å½’çš„ã€‚

### 6. åˆ¤æ–­è·¯å¾„å’Œæ˜¯å¦ç­‰äºä¸€ä¸ªæ•°

Leetcdoe : 112. Path Sum (Easy)

[Leetcode](https://leetcode.com/problems/path-sum/description/) / [åŠ›æ‰£](https://leetcode-cn.com/problems/path-sum/description/)

```html
Given the below binary tree and sum = 22,

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1

return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.
```

è·¯å¾„å’Œå®šä¹‰ä¸ºä» root åˆ° leaf çš„æ‰€æœ‰èŠ‚ç‚¹çš„å’Œã€‚

æ€è·¯ï¼š

ä½¿ç”¨é€’å½’æ–¹æ³•åšï¼Œéœ€è¦æ‰¾åˆ°base caseã€‚

- è¿™é‡Œçš„base case æœ‰ä¸¤ä¸ªï¼Œä¸€ä¸ªæ˜¯root == nullï¼Œè¿™æ˜¯æ ¹æœ¬ä¸å­˜åœ¨æ•°ï¼Œå› æ­¤ä¸ºfalseï¼›
- ä¸€ä¸ªæ˜¯æˆåŠŸæ¡ˆä¾‹ï¼Œå¦‚æœåªæœ‰ä¸€ä¸ªnodeï¼Œæ²¡æœ‰æå¹²ï¼Œroot.val == sum åˆ™ä¸º trueï¼›

æ˜“é”™ç‚¹ï¼š

- trueå’Œfalseä¸èƒ½å†™é”™ã€‚
- åˆ¤æ–­æ¡ä»¶== ä¸èƒ½å†™é”™ã€‚

```java
public boolean hasPathSum(TreeNode root, int sum) {
    if (root == null) return false;
    if (root.left == null && root.right == null && root.val == sum) return true;
    return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
}
```

### 7. ç»Ÿè®¡è·¯å¾„å’Œç­‰äºä¸€ä¸ªæ•°çš„è·¯å¾„æ•°é‡

437\. Path Sum III (Easy)

[Leetcode](https://leetcode.com/problems/path-sum-iii/description/) / [åŠ›æ‰£](https://leetcode-cn.com/problems/path-sum-iii/description/)

```html
root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

Return 3. The paths that sum to 8 are:

1.  5 -> 3
2.  5 -> 2 -> 1
3. -3 -> 11
```

è·¯å¾„ä¸ä¸€å®šä»¥ root å¼€å¤´ï¼Œä¹Ÿä¸ä¸€å®šä»¥ leaf ç»“å°¾ï¼Œä½†æ˜¯å¿…é¡»è¿ç»­ã€‚

```java
public int pathSum(TreeNode root, int sum) {
    if (root == null) return 0;
    int ret = pathSumStartWithRoot(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);
    return ret;
}

private int pathSumStartWithRoot(TreeNode root, int sum) {
    if (root == null) return 0;
    int ret = 0;
    if (root.val == sum) ret++;
    ret += pathSumStartWithRoot(root.left, sum - root.val) + pathSumStartWithRoot(root.right, sum - root.val);
    return ret;
}
```

è¿™ä¸ªé¢˜çš„æ€è·¯çœŸçš„æ˜¯æäº†æˆ‘å¾ˆä¹…ã€‚

pathSumèƒ½å¤Ÿè®¡ç®—å’Œä¸ºtargetSumçš„pathæ•°ç›®ï¼Œè¿™äº›pathä¸éœ€è¦ä»rootå¼€å§‹ï¼Œä¹Ÿä¸éœ€è¦ä»leafç»“å°¾ã€‚

å¯ä»¥åˆ†ä¸ºä¸¤ç§æƒ…å†µï¼š

åŒ…æ‹¬rootï¼šæ­¤æ—¶ï¼Œå°±å¿…é¡»ä»rootä¸€è·¯å‘ä¸‹ï¼Œæ‰¾å‡ºæ‰€æœ‰ä»¥rootä¸ºèµ·å§‹ç‚¹å’Œä¸ºtargetSumçš„pathï¼Œå¾—åˆ°æ€»æ•°ã€‚å…³é”®ç‚¹æ˜¯ä¸€æ¡pathä¸Šå¯èƒ½ä¼šæœ‰å¤šä¸ªæ»¡è¶³ç»“æœä¸ºtargetSumçš„pathã€‚

- ä»¥rootä¸ºèµ·ç‚¹
- ç»ˆç‚¹ä¸ç¡®å®šï¼Œéå¸¸çµæ´»

ä¸åŒ…æ‹¬rootï¼šåˆ†ä¸ºå‘å·¦å’Œå‘å³ï¼Œè¿™æ—¶åˆå’Œè®¡ç®—pathSumä¸€æ ·äº†ï¼Œå› ä¸ºä½ ä¸çŸ¥é“æ˜¯å¦åŒ…å«root.leftæˆ–è€…root.rightã€‚

```java
public int pathSum(TreeNode root, int targetSum) {
    if (root == null) return 0;
    int ret = inclueRoot(root, targetSum) + pathSum(root.left, targetSum) + pathSum(root.right, targetSum);
    return ret;
}

public int inclueRoot(TreeNode root, int targetSum) {
    int ret = 0;
    if (root.val == targetSum) ret++;
    int l = inclueRoot(root.left, targetSum - root.val);
    int r = inclueRoot(root.right, targetSum - root.val);
    ret += l+r;
    
    return ret;
}
```



### 8. å­æ ‘

572\. Subtree of Another Tree (Easy)

[Leetcode](https://leetcode.com/problems/subtree-of-another-tree/description/) / [åŠ›æ‰£](https://leetcode-cn.com/problems/subtree-of-another-tree/description/)

```html
Given tree s:
     3
    / \
   4   5
  / \
 1   2

Given tree t:
   4
  / \
 1   2

Return true, because t has the same structure and node values with a subtree of s.

Given tree s:

     3
    / \
   4   5
  / \
 1   2
    /
   0

Given tree t:
   4
  / \
 1   2

Return false.
```

```java
public boolean isSubtree(TreeNode s, TreeNode t) {
    if (s == null) return false;
    return isSubtreeWithRoot(s, t) || isSubtree(s.left, t) || isSubtree(s.right, t);
}

private boolean isSubtreeWithRoot(TreeNode s, TreeNode t) {
    if (t == null && s == null) return true;
    if (t == null || s == null) return false;
    if (t.val != s.val) return false;
    return isSubtreeWithRoot(s.left, t.left) && isSubtreeWithRoot(s.right, t.right);
}
```

æ€è·¯ï¼š

- é¦–å…ˆå…³é”®åœ¨äºå¯¹å­æ ‘çš„ç†è§£ï¼š äºŒå‰æ ‘ `tree` çš„ä¸€æ£µå­æ ‘åŒ…æ‹¬ `tree` çš„æŸä¸ªèŠ‚ç‚¹å’Œè¿™ä¸ªèŠ‚ç‚¹çš„æ‰€æœ‰åä»£èŠ‚ç‚¹ã€‚`tree` ä¹Ÿå¯ä»¥çœ‹åšå®ƒè‡ªèº«çš„ä¸€æ£µå­æ ‘ã€‚

- å› æ­¤åˆ¤æ–­subrootæ˜¯å¦ä¸ºrootçš„å­æ ‘ï¼Œ
  - ç­‰ä»·äº subroot == root æˆ–è€…ï¼Œ
  - subrootæ˜¯root.leftçš„å­æ ‘
  - åˆæˆ–è€…subrootæ˜¯root.rightçš„å­æ ‘ã€‚
- åˆ¤æ–­ä¸¤ä¸ªæ ‘æ˜¯å¦ç›¸åŒ



- å­æ ‘è¦æ±‚Aä¸­ä»¥æŸä¸€èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„æ ‘å’ŒBå®Œå…¨ç›¸åŒã€‚
- **é¦–å…ˆéå†Açš„æ‰€æœ‰èŠ‚ç‚¹nAï¼Œç„¶åçœ‹ä»¥nAä¸ºæ ¹èŠ‚ç‚¹çš„å­æ ‘å’ŒBæ˜¯å¦ç›¸åŒã€‚**,å½“ä¸ºç©ºçš„æ—¶å€™ï¼Œè‡ªç„¶ä¸ä¸€å®šæˆåŠŸï¼Œå½“ç›¸åŒçš„æ—¶å€™åˆ™æˆåŠŸã€‚





### 9. æ ‘çš„å¯¹ç§°

101\. Symmetric Tree (Easy)

[Leetcode](https://leetcode.com/problems/symmetric-tree/description/) / [åŠ›æ‰£](https://leetcode-cn.com/problems/symmetric-tree/description/)

```html
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

```java
public boolean isSymmetric(TreeNode root) {
    if (root == null) return true;
    return isSymmetric(root.left, root.right);
}

private boolean isSymmetric(TreeNode t1, TreeNode t2) {
    if (t1 == null && t2 == null) return true;
    if (t1 == null || t2 == null) return false;// è¿™é‡Œä½¿ç”¨çš„å¥—è·¯å’Œä¸Šä¸€é¢˜ä¸€æ¨¡ä¸€æ ·ï¼Œä¸åŒæ—¶ä¸ºnullï¼Œ åˆ™ä¸å¯ä»¥ã€‚
    if (t1.val != t2.val) return false;
    return isSymmetric(t1.left, t2.right) && isSymmetric(t1.right, t2.left);
}
```

å‚ç…§å¤§ä½¬çš„æ€è€ƒï¼š

é€’å½’çš„éš¾ç‚¹åœ¨äºï¼šæ‰¾åˆ°å¯ä»¥é€’å½’çš„ç‚¹ ä¸ºä»€ä¹ˆå¾ˆå¤šäººè§‰å¾—é€’å½’ä¸€çœ‹å°±ä¼šï¼Œä¸€å†™å°±åºŸã€‚ æˆ–è€…è¯´æ˜¯è‡ªå·±å†™æ— æ³•å†™å‡ºæ¥ï¼Œå…³é”®å°±æ˜¯ä½ å¯¹é€’å½’ç†è§£çš„æ·±ä¸æ·±ã€‚

å¯¹äºæ­¤é¢˜ï¼š é€’å½’çš„ç‚¹æ€ä¹ˆæ‰¾ï¼Ÿä»æ‹¿åˆ°é¢˜çš„ç¬¬ä¸€æ—¶é—´å¼€å§‹ï¼Œæ€è·¯å¦‚ä¸‹ï¼š

1.æ€ä¹ˆåˆ¤æ–­ä¸€æ£µæ ‘æ˜¯ä¸æ˜¯å¯¹ç§°äºŒå‰æ ‘ï¼Ÿ ç­”æ¡ˆï¼šå¦‚æœæ‰€ç»™æ ¹èŠ‚ç‚¹ï¼Œä¸ºç©ºï¼Œé‚£ä¹ˆæ˜¯å¯¹ç§°ã€‚å¦‚æœä¸ä¸ºç©ºçš„è¯ï¼Œå½“ä»–çš„å·¦å­æ ‘ä¸å³å­æ ‘å¯¹ç§°æ—¶ï¼Œä»–å¯¹ç§°

2.é‚£ä¹ˆæ€ä¹ˆçŸ¥é“å·¦å­æ ‘ä¸å³å­æ ‘å¯¹ä¸å¯¹ç§°å‘¢ï¼Ÿåœ¨è¿™æˆ‘ç›´æ¥å«ä¸ºå·¦æ ‘å’Œå³æ ‘ ç­”æ¡ˆï¼šå¦‚æœå·¦æ ‘çš„å·¦å­©å­ä¸å³æ ‘çš„å³å­©å­å¯¹ç§°ï¼Œå·¦æ ‘çš„å³å­©å­ä¸å³æ ‘çš„å·¦å­©å­å¯¹ç§°ï¼Œé‚£ä¹ˆè¿™ä¸ªå·¦æ ‘å’Œå³æ ‘å°±å¯¹ç§°ã€‚

ä»”ç»†è¯»è¿™å¥è¯ï¼Œæ˜¯ä¸æ˜¯æœ‰ç‚¹ç»•ï¼Ÿæ€ä¹ˆæ„Ÿè§‰æœ‰ä¸€ä¸ªåŠŸèƒ½Aæˆ‘æƒ³å®ç°ï¼Œä½†æˆ‘å»å®ç°Açš„æ—¶å€™åˆè¦ç”¨åˆ°Aå®ç°åçš„åŠŸèƒ½å‘¢ï¼Ÿ

å½“ä½ æ€è€ƒåˆ°è¿™é‡Œçš„æ—¶å€™ï¼Œé€’å½’ç‚¹å·²ç»å‡ºç°äº†ï¼š é€’å½’ç‚¹ï¼šæˆ‘åœ¨å°è¯•åˆ¤æ–­å·¦æ ‘ä¸å³æ ‘å¯¹ç§°çš„æ¡ä»¶æ—¶ï¼Œå‘ç°å…¶è·Ÿä¸¤æ ‘çš„å­©å­çš„å¯¹ç§°æƒ…å†µæœ‰å…³ç³»ã€‚

æƒ³åˆ°è¿™é‡Œï¼Œä½ ä¸å¿…æœ‰å¤ªå¤šç–‘é—®ï¼Œä¸Šæ‰‹å»æŒ‰æ€è·¯å†™ä»£ç ï¼Œå‡½æ•°Aï¼ˆå·¦æ ‘ï¼Œå³æ ‘ï¼‰åŠŸèƒ½æ˜¯è¿”å›æ˜¯å¦å¯¹ç§°

def å‡½æ•°Aï¼ˆå·¦æ ‘ï¼Œå³æ ‘ï¼‰ï¼š å·¦æ ‘èŠ‚ç‚¹å€¼ç­‰äºå³æ ‘èŠ‚ç‚¹å€¼ ä¸” å‡½æ•°Aï¼ˆå·¦æ ‘çš„å·¦å­æ ‘ï¼Œå³æ ‘çš„å³å­æ ‘ï¼‰ï¼Œå‡½æ•°Aï¼ˆå·¦æ ‘çš„å³å­æ ‘ï¼Œå³æ ‘çš„å·¦å­æ ‘ï¼‰å‡ä¸ºçœŸ æ‰è¿”å›çœŸ

å®ç°å®Œæ¯•ã€‚ã€‚ã€‚

å†™ç€å†™ç€ã€‚ã€‚ã€‚ä½ å°±å‘ç°ä½ å†™å‡ºæ¥äº†ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚



ä¸€ä¸ªæ ‘æ˜¯å¦å¯¹ç§° ä¸ ä¸¤ä¸ªæ•°æ˜¯å¦å¯¹ç§° å…¶å®è§£å†³çš„æ˜¯åŒä¸€ä¸ªé—®é¢˜

ä¸€ä¸ªæ ‘æ˜¯å¦å¯¹ç§° == å·¦æ ‘å’Œå³æ ‘æ˜¯å¦å¯¹ç§°

ä¸¤ä¸ªæ ‘æ˜¯å¦å¯¹ç§° == å…¶å­æ ‘æ˜¯å¦åˆ†åˆ«å¯¹ç§°



```java
public boolean isSymmetric(TreeNode root) {
    if(root == null) return true;
    return isSymmetricTwo(root.left, root.right);
}

public boolean isSymmetricTwo(TreeNode root1, TreeNode root2) {
    if (root1==null && root2==null) return true;
    if (root1==null || root2==null) return false;
    
    if (root1.val != root2.val) return false;
    return isSymmetricTwo(root1.left, root2.right) && isSymmetricTwo(root1.right, roog2.left);
}
```



### 10. æœ€å°è·¯å¾„

111\. Minimum Depth of Binary Tree (Easy)

[Leetcode](https://leetcode.com/problems/minimum-depth-of-binary-tree/description/) / [åŠ›æ‰£](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/description/)

æ ‘çš„æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„æœ€å°è·¯å¾„é•¿åº¦

```java
public int minDepth(TreeNode root) {
    if (root == null) return 0;
    int left = minDepth(root.left);
    int right = minDepth(root.right);
    if (left == 0 || right == 0) return left + right + 1;
    return Math.min(left, right) + 1;
}
```

æ€è·¯ï¼š

å…³é”®åœ¨äºæœ€å°è·¯å¾„é•¿åº¦çš„å®šä¹‰ï¼šæ ‘çš„æ ¹èŠ‚ç‚¹åˆ°å¶å­ç»“ç‚¹çš„è·¯å¾„ã€‚ å¶å­ç»“ç‚¹å°±æ˜¯ä¸¤ä¸ªchildrenéƒ½ä¸ºnullçš„èŠ‚ç‚¹ã€‚å¦‚æœleftæˆ–è€…rightä¸­æœ‰ä¸€ä¸ªä¸ºnullçš„è¯ï¼Œæˆ‘ä»¬å°±ä¸èƒ½å°†è¿™ä¸¤ä¸ªè¿›è¡Œæ¯”è¾ƒï¼Œè€Œåº”è¯¥åªçœ‹å¦ä¸€ä¸ªã€‚ åªæœ‰leftå’Œrightéƒ½ä¸ä¸ºnullçš„æ—¶å€™ï¼Œæˆ‘ä»¬æ‰èƒ½æ¯”è¾ƒä¸¤ä¸ªçš„ä¸åŒã€‚

- æœ€å°æ·±åº¦ï¼šæ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„æ·±åº¦ï¼Œä¸€å®šè¦åˆ°å¶å­èŠ‚ç‚¹æ‰è¡Œã€‚ 
- å¦‚æœæœ‰ä¸€è¾¹æ˜¯æ²¡æœ‰å¶å­ç»“ç‚¹çš„ï¼Œé‚£ä¹ˆå°±ä¸è€ƒè™‘

```java
public int minDepth(TreeNode root) {
    if (root == null) return 0;
    int l = minDepth(root.left);
    int r = minDepth(root.right);
    
    if(l==0 || r==0) return l+r+1;
    return Math.min(l,r)+1;
}
```

å¯ä»¥ä½¿ç”¨å±‚åºéå†çš„æ–¹æ³•ï¼Œå¾—åˆ°æœ€çŸ­è·¯å¾„ï¼š

depthå¦‚ä½•åŠ å‡ï¼š

- åœ¨éå†åˆ°å“ªä¸€å±‚æ—¶è¿›è¡Œæ·»åŠ ï¼Œè¿™é‡Œéå†åˆ°å“ªä¸€å±‚æ˜¯æŒ‡å¯¹å±‚çš„forå¾ªç¯ã€‚
- æˆ–è€…åœ¨è¿›å…¥queueä¹‹åï¼Œå°±è®©depth+1



### 11. ç»Ÿè®¡å·¦å¶å­èŠ‚ç‚¹çš„å’Œ

404\. Sum of Left Leaves (Easy)

[Leetcode](https://leetcode.com/problems/sum-of-left-leaves/description/) / [åŠ›æ‰£](https://leetcode-cn.com/problems/sum-of-left-leaves/description/)

```html
    3
   / \
  9  20
    /  \
   15   7

There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.
```

```java
public int sumOfLeftLeaves(TreeNode root) {
    if (root == null) return 0;
    if (isLeaf(root.left)) return root.left.val + sumOfLeftLeaves(root.right);
    return sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);
}

private boolean isLeaf(TreeNode node){
    if (node == null) return false;
    return node.left == null && node.right == null;
}
```

æ€è·¯ï¼š

- base caseï¼š
  - root == null return 0
  - æœ‰å·¦å¶å­èŠ‚ç‚¹å­˜åœ¨
- å·¦å³æ ‘çš„å·¦å³å­èŠ‚ç‚¹çš„å’Œ

å…³é”®åœ¨äºæ±‚çš„æ˜¯å·¦å¶èŠ‚ç‚¹ï¼Œè¦ææ¸…æ¥šä»€ä¹ˆæ˜¯å·¦å¶èŠ‚ç‚¹ã€‚ å°±æ˜¯å·¦è¾¹çš„å¶ç»“ç‚¹ã€‚

ä¸¤ä¸ªç‰¹ç‚¹ï¼šåœ¨å·¦è¾¹ï¼Œè€Œä¸”æ˜¯å¶ç»“ç‚¹

- å·¦å¶å­èŠ‚ç‚¹çš„å’Œ

- åˆ¤æ–­æ˜¯å¦ä¸ºç»“ç‚¹æ˜¯å¦ä¸ºå¶å­ç»“ç‚¹

- ç´¯åŠ çš„æ–¹æ³•

  ```java
  public int sumOfLeftLeaves(TreeNode root) {
      if (root == null) return 0;
      int ret = 0;
      if (isLeaf(root.left)) ret += root.left.val;
      
      ret += sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);
      return ret;
  }
  ```


éå†æ¯ä¸€ä¸ªç»“ç‚¹ï¼Œå¹¶å°†æ‰€æœ‰çš„å¶èŠ‚ç‚¹åŠ èµ·æ¥ã€‚

### 12. ç›¸åŒèŠ‚ç‚¹å€¼çš„æœ€å¤§è·¯å¾„é•¿åº¦

687\. Longest Univalue Path (Easy)

[Leetcode](https://leetcode.com/problems/longest-univalue-path/) / [åŠ›æ‰£](https://leetcode-cn.com/problems/longest-univalue-path/)

```html
             1
            / \
           4   5
          / \   \
         4   4   5

Output : 2
```

```java
private int path = 0;

public int longestUnivaluePath(TreeNode root) {
    dfs(root);
    return path;
}

private int dfs(TreeNode root){
    if (root == null) return 0;
    int left = dfs(root.left);
    int right = dfs(root.right);
    int leftPath = root.left != null && root.left.val == root.val ? left + 1 : 0;
    int rightPath = root.right != null && root.right.val == root.val ? right + 1 : 0;
    path = Math.max(path, leftPath + rightPath);
    return Math.max(leftPath, rightPath);
}
```

æ€è·¯ï¼š

æ±‚å•è¾¹çš„æœ€é•¿åŒå€¼è·¯å¾„é•¿åº¦

ç„¶åå’Œæœ€å¤§ç›´å¾„é‚£é“é¢˜ç›®ä¸€æ ·

æœ¬è´¨ä¸Šï¼š 

æ±‚è·¯å¾„é•¿åº¦-->æ±‚æ·±åº¦

å› ä¸ºåœ¨æ±‚è·¯å¾„é•¿åº¦çš„æ—¶å€™ï¼Œè¦è¿›è¡Œé€’å½’ï¼Œå°±ä¸€å®šéœ€è¦å·¦å³ä¸¤è¾¹çš„è·¯å¾„é•¿åº¦ã€‚

è€Œåœ¨æ±‚æ·±åº¦çš„æ—¶å€™ï¼Œå¯ä»¥å°†æ‰€æœ‰çš„å•è¾¹çš„è·¯å¾„é•¿åº¦å…¨éƒ¨æ±‚ä¸€éï¼Œè¿™æ ·å°±éå¸¸çš„å¿«



- å¯¹æœ€é•¿åŒå€¼è·¯å¾„çš„ç†è§£ï¼Œä»¥æ¯ä¸ªèŠ‚ç‚¹ä¸ºåŸºç¡€å¾—åˆ°çš„ç»“æœä¸­çš„æœ€å¤§å€¼
-   æ¯ä¸ªç»“ç‚¹å¤„åŒå€¼è·¯å¾„ä¸ºå·¦å³åŒå€¼è·¯å¾„å’Œ
-  å•è¾¹åŒå€¼è·¯å¾„é•¿ä¸º0æˆ–è€…å­åŒå€¼è·¯å¾„+1



### 13. é—´éš”éå†

337\. House Robber III (Medium)

[Leetcode](https://leetcode.com/problems/house-robber-iii/description/) / [åŠ›æ‰£](https://leetcode-cn.com/problems/house-robber-iii/description/)

```html
     3
    / \
   2   3
    \   \
     3   1
Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.
```

```java
Map<TreeNode, Integer> cache = new HashMap<>(); 

public int rob(TreeNode root) {
    if (root == null) return 0;
    if (cache.containsKey(root)) return cache.get(root);
    int val1 = root.val;
    if (root.left != null) val1 += rob(root.left.left) + rob(root.left.right);
    if (root.right != null) val1 += rob(root.right.left) + rob(root.right.right);
    int val2 = rob(root.left) + rob(root.right);
    int res = Math.max(val1, val2);
    cache.put(root, res);
    return res;
}
```

### 14. æ‰¾å‡ºäºŒå‰æ ‘ä¸­ç¬¬äºŒå°çš„èŠ‚ç‚¹

671\. Second Minimum Node In a Binary Tree (Easy)

[Leetcode](https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/description/) / [åŠ›æ‰£](https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/description/)

```html
Input:
   2
  / \
 2   5
    / \
    5  7

Output: 5
```

ä¸€ä¸ªèŠ‚ç‚¹è¦ä¹ˆå…·æœ‰ 0 ä¸ªæˆ– 2 ä¸ªå­èŠ‚ç‚¹ï¼Œå¦‚æœæœ‰å­èŠ‚ç‚¹ï¼Œé‚£ä¹ˆæ ¹èŠ‚ç‚¹æ˜¯æœ€å°çš„èŠ‚ç‚¹ã€‚

æ€è·¯ï¼š

æ ¹èŠ‚ç‚¹çš„å€¼æ˜¯æœ€å°çš„å€¼ï¼Œæ±‚ç¬¬äºŒå°çš„å€¼ç­‰ä»·äºæ±‚é™¤äº†æ ¹èŠ‚ç‚¹ä»¥å¤–çš„å€¼ä¸­çš„æœ€å°å€¼ã€‚

å¦‚æœæ‰¾ä¸åˆ°ï¼Œé‚£å°±è¿”å›-1.

å¯ä»¥ç”¨éå†çš„æ–¹æ³•è§£å†³ã€‚

```java
public int findSecondMinimumValue(TreeNode root) {
    if (root == null) return -1;
    if (root.left == null && root.right == null) return -1;
    int leftVal = root.left.val;
    int rightVal = root.right.val;
    if (leftVal == root.val) leftVal = findSecondMinimumValue(root.left);
    if (rightVal == root.val) rightVal = findSecondMinimumValue(root.right);
    if (leftVal != -1 && rightVal != -1) return Math.min(leftVal, rightVal);
    if (leftVal != -1) return leftVal;
    return rightVal;
}
```

### [297. äºŒå‰æ ‘çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–ï¼ˆå›°éš¾ï¼‰](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree)

if val == '#': return None
è¿™æ—¶å€™æ˜¯è¡¨ç¤ºä¸€ä¸ªæå¹²å·²ç»éå†åˆ°åº•äº†ï¼Œç„¶åå°±éå†ä¸‹ä¸€ä¸ª

åªè¦èƒ½å¤Ÿå°†ä¸€é¢—äºŒå‰æ ‘åºåˆ—åŒ–ä¹‹åï¼Œå†è½¬åŒ–ä¸ºåŸæ¥çš„æ ·å­å°±å¯ä»¥äº†ã€‚



### [450. åˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„èŠ‚ç‚¹ï¼ˆä¸­ç­‰ï¼‰](https://leetcode-cn.com/problems/delete-node-in-a-bst)

è¿™ä¸ªé¢˜ç›®è¿˜æ˜¯æŒºæœ‰æ„æ€çš„ï¼Œæ ¹æ®keyæ¥å¯¹bstè¿›è¡Œåˆ é™¤ï¼Œ

é¦–å…ˆè¦ä½¿ç”¨bstçš„ç‰¹å®šï¼Œå·¦è¾¹å°ï¼Œå³è¾¹å¤§ï¼Œ

## å±‚æ¬¡éå†

ä½¿ç”¨ BFS è¿›è¡Œå±‚æ¬¡éå†ã€‚ä¸éœ€è¦ä½¿ç”¨ä¸¤ä¸ªé˜Ÿåˆ—æ¥åˆ†åˆ«å­˜å‚¨å½“å‰å±‚çš„èŠ‚ç‚¹å’Œä¸‹ä¸€å±‚çš„èŠ‚ç‚¹ï¼Œå› ä¸ºåœ¨å¼€å§‹éå†ä¸€å±‚çš„èŠ‚ç‚¹æ—¶ï¼Œå½“å‰é˜Ÿåˆ—ä¸­çš„èŠ‚ç‚¹æ•°å°±æ˜¯å½“å‰å±‚çš„èŠ‚ç‚¹æ•°ï¼Œåªè¦æ§åˆ¶éå†è¿™ä¹ˆå¤šèŠ‚ç‚¹æ•°ï¼Œå°±èƒ½ä¿è¯è¿™æ¬¡éå†çš„éƒ½æ˜¯å½“å‰å±‚çš„èŠ‚ç‚¹ã€‚

### 1. ä¸€æ£µæ ‘æ¯å±‚èŠ‚ç‚¹çš„å¹³å‡æ•°

637\. Average of Levels in Binary Tree (Easy)

[Leetcode](https://leetcode.com/problems/average-of-levels-in-binary-tree/description/) / [åŠ›æ‰£](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/description/)

```java
public List<Double> averageOfLevels(TreeNode root) {
    List<Double> ret = new ArrayList<>();
    if (root == null) return ret;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    while (!queue.isEmpty()) {
        int cnt = queue.size();
        double sum = 0;
        for (int i = 0; i < cnt; i++) {
            TreeNode node = queue.poll();
            sum += node.val;
            if (node.left != null) queue.add(node.left);
            if (node.right != null) queue.add(node.right);
        }
        ret.add(sum / cnt);
    }
    return ret;
}
```

 \# å±‚æ¬¡éå†, queue, ä¿è¯queueé‡Œé¢æ²¡æœ‰None

â€‹    \# æ¯ä¸€å±‚çš„å¹³å‡å€¼ = æ¯ä¸€å±‚çš„å’Œ / æ¯ä¸€å±‚çš„ä¸ªæ•°

â€‹    \# res

### 2. å¾—åˆ°å·¦ä¸‹è§’çš„èŠ‚ç‚¹

513\. Find Bottom Left Tree Value (Easy)

[Leetcode](https://leetcode.com/problems/find-bottom-left-tree-value/description/) / [åŠ›æ‰£](https://leetcode-cn.com/problems/find-bottom-left-tree-value/description/)

```html
Input:

        1
       / \
      2   3
     /   / \
    4   5   6
       /
      7

Output:
7
```

```java
public int findBottomLeftValue(TreeNode root) {
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    while (!queue.isEmpty()) {
        root = queue.poll();
        if (root.right != null) queue.add(root.right);
        if (root.left != null) queue.add(root.left);
    }
    return root.val;
}
```

æ–¹æ³•ä¸€ï¼š

- é¦–å…ˆæ‰¾æœ€æ·±çš„ä¸€å±‚ï¼Œç„¶åå†æ‰¾æœ€å·¦è¾¹çš„ä¸€ä¸ªã€‚
-  å¯ä»¥ç”¨dfsï¼Œå› ä¸ºæ˜¯å…ˆä¸­-å·¦-å³ï¼Œå…ˆå·¦è¾¹åå³è¾¹ï¼Œæ‰€ä»¥åœ¨æœ€æ·±ä¸€å±‚æ˜¯depthç›¸åŒ
-  å°±åªä¼šä¿ç•™ç¬¬ä¸€ä¸ª

æ–¹æ³•äºŒï¼š

ä½¿ç”¨å±‚æ¬¡éå†ï¼Œå±‚æ¬¡éå†å°±æ˜¯å®Œå…¨ä»å·¦å¾€å³ï¼Œæˆ–è€…ä»å³å¾€å·¦ã€‚å› æ­¤å¯ä»¥ä½¿ç”¨æ‰¾æœ€å·¦è¾¹çš„ï¼Œå°±å¯ä»¥ä»å³å¾€å·¦å¼€å§‹ã€‚

## å‰ä¸­ååºéå†

```html
    1
   / \
  2   3
 / \   \
4   5   6
```

- å±‚æ¬¡éå†é¡ºåºï¼š[1 2 3 4 5 6]
- å‰åºéå†é¡ºåºï¼š[1 2 4 5 3 6]
- ä¸­åºéå†é¡ºåºï¼š[4 2 5 1 3 6]
- ååºéå†é¡ºåºï¼š[4 5 2 6 3 1]

å±‚æ¬¡éå†ä½¿ç”¨ BFS å®ç°ï¼Œåˆ©ç”¨çš„å°±æ˜¯ BFS ä¸€å±‚ä¸€å±‚éå†çš„ç‰¹æ€§ï¼›è€Œå‰åºã€ä¸­åºã€ååºéå†åˆ©ç”¨äº† DFS å®ç°ã€‚

å‰åºã€ä¸­åºã€ååºéåªæ˜¯åœ¨å¯¹èŠ‚ç‚¹è®¿é—®çš„é¡ºåºæœ‰ä¸€ç‚¹ä¸åŒï¼Œå…¶å®ƒéƒ½ç›¸åŒã€‚

â‘  å‰åº

```java
void dfs(TreeNode root) {
    visit(root);
    dfs(root.left);
    dfs(root.right);
}
```

â‘¡ ä¸­åº

```java
void dfs(TreeNode root) {
    dfs(root.left);
    visit(root);
    dfs(root.right);
}
```

â‘¢ ååº

```java
void dfs(TreeNode root) {
    dfs(root.left);
    dfs(root.right);
    visit(root);
}
```

### 1. éé€’å½’å®ç°äºŒå‰æ ‘çš„å‰åºéå†

æ—¢ç„¶å¯ä»¥ç”¨é€’å½’å®ç°ï¼Œè€Œé€’å½’çš„å®è´¨å…¶å®å°±æ˜¯æ ˆï¼Œé‚£ä¹ˆè¿­ä»£æ³•éå†å¾ˆæ˜¾ç„¶å°±æ˜¯ä¼šç”¨åˆ°æ ˆã€‚ä½†æ˜¯å…¥æ ˆå’Œå‡ºæ ˆçš„é¡ºåºæ˜¯éœ€è¦è€ƒè™‘æ¸…æ¥šçš„ï¼Œæ„Ÿè§‰è‡ªå·±ç»å¸¸ä¼šå¿˜è®°æ€ä¹ˆå¤„ç†è¿™ä¸ªé¡ºåºï¼Œä»è€Œå¯¼è‡´ä»£ç åˆä¸ä¼šå†™äº†ï¼Œé‚£ä¹ˆä»Šå¤©å°±æ¥æ€»ç»“ä¸€ä¸ªè¿™ä¸ªå…¥æ ˆå‡ºæ ˆçš„é¡ºåºï¼Œé€»è¾‘ç†é¡ºäº†ï¼Œä»£ç å°±ä¸éš¾å†™äº†ã€‚

144\. Binary Tree Preorder Traversal (Medium)

[Leetcode](https://leetcode.com/problems/binary-tree-preorder-traversal/description/) / [åŠ›æ‰£](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/description/)

ä¸­-å·¦-å³

å‰åºéå†çš„å…³é”®åœ¨äº

```java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> ret = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        if (node == null) continue;
        ret.add(node.val);
        stack.push(node.right);  // å…ˆå³åå·¦ï¼Œä¿è¯å·¦å­æ ‘å…ˆéå†
        stack.push(node.left);
    }
    return ret;
}
```

```python
## dpæ–¹æ³•
def preOrderTraverse(self, root):
    if root is None:
        return []
    
    res = []
    res.append(root.val)
    res.extend(self.preOrderTraverse(root.left))
    res.extend(self.preOrderTraverse(root.right))
## traverseæ–¹æ³•
def preOrderTraverse(self, root):
    self.res = []
    self.traverse(root)
    return self.res

def traverse(self, root):
    if root is None:
        return
    self.res.append(root.val)
    self.traverse(root.left)
    self.traverse(root.right)

## è¿­ä»£æ–¹æ³•
def preOrderTraverse(self, root):
    if root is None:
        return []
    
    res = []
    stack = []
    stack.append(root)
    while stack:
        cur = stack.pop()
        res.append(cur.val)
        if cur.right:
            res.append(cur.right)
		if cur.left:
            res.append(cur.left)
            
	return res
 
```



### 2. éé€’å½’å®ç°äºŒå‰æ ‘çš„ååºéå†

145\. Binary Tree Postorder Traversal (Medium)

[Leetcode](https://leetcode.com/problems/binary-tree-postorder-traversal/description/) / [åŠ›æ‰£](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/description/)

å‰åºéå†ä¸º root -\> left -\> rightï¼Œååºéå†ä¸º left -\> right -\> rootã€‚å¯ä»¥ä¿®æ”¹å‰åºéå†æˆä¸º root -\> right -\> leftï¼Œé‚£ä¹ˆè¿™ä¸ªé¡ºåºå°±å’Œååºéå†æ­£å¥½ç›¸åã€‚

ä½¿ç”¨è¿­ä»£çš„æ–¹æ³•ï¼šååºéå†æ˜¯å·¦å³ä¸­ï¼Œé€†åºä¹‹åæ˜¯ä¸­å³å·¦ã€‚å…ˆåºéå†æ˜¯ä¸­å·¦å³ã€‚åªéœ€è¦æŠŠå…ˆåºéå†ä¸­å…ˆèµ°å·¦åˆ†æ”¯çš„éƒ¨åˆ†æ”¹ä¸ºå³åˆ†æ”¯å³å¯ã€‚ç»“æœå†reverseã€‚æˆ–è€…åƒè¿™ä¸ªç­”ä¸»è§£æ³•ä¸€æ ·å¯¹res addFirstï¼Œçœå»reverseçš„è¿‡ç¨‹ã€‚

```java
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> ret = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        if (node == null) continue;
        ret.add(node.val);
        stack.push(node.left);
        stack.push(node.right);
    }
    Collections.reverse(ret);
    return ret;
}
```

### 3. éé€’å½’å®ç°äºŒå‰æ ‘çš„ä¸­åºéå†

94\. Binary Tree Inorder Traversal (Medium)



[Leetcode](https://leetcode.com/problems/binary-tree-inorder-traversal/description/) / [åŠ›æ‰£](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/description/)

```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> ret = new ArrayList<>();
    if (root == null) return ret;
    Stack<TreeNode> stack = new Stack<>();
    TreeNode cur = root;
    while (cur != null || !stack.isEmpty()) {
        while (cur != null) {
            stack.push(cur);
            cur = cur.left;
        }
        TreeNode node = stack.pop();
        ret.add(node.val);
        cur = node.right;
    }
    return ret;
}
```

å‚è€ƒé¢˜è§£ï¼š

https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/dong-hua-yan-shi-94-er-cha-shu-de-zhong-xu-bian-li/



ä¸­åºéå†ï¼š

https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/dai-ma-sui-xiang-lu-chi-tou-qian-zhong-hou-xu-de-d/



è§†é¢‘è®²è§£ï¼š

https://www.youtube.com/watch?v=QxFOR8sQuB4

<img src="https://inews.gtimg.com/newsapp_ls/0/14490735432/0.jiketuchuang.png" alt="image.png" title="image.png" />

ä¸¤ä¸ªæ“ä½œï¼š

1. **å¤„ç†ï¼šå°†å…ƒç´ æ”¾è¿›resultæ•°ç»„ä¸­**
2. **è®¿é—®ï¼šéå†èŠ‚ç‚¹**

ä¸­åºéå†æ˜¯å·¦ä¸­å³ï¼Œå…ˆè®¿é—®çš„æ˜¯äºŒå‰æ ‘é¡¶éƒ¨çš„èŠ‚ç‚¹ï¼Œç„¶åä¸€å±‚ä¸€å±‚å‘ä¸‹è®¿é—®ï¼Œç›´åˆ°åˆ°è¾¾æ ‘å·¦é¢çš„æœ€åº•éƒ¨ï¼Œå†å¼€å§‹å¤„ç†èŠ‚ç‚¹ï¼ˆä¹Ÿå°±æ˜¯åœ¨æŠŠèŠ‚ç‚¹çš„æ•°å€¼æ”¾è¿›resultæ•°ç»„ä¸­ï¼‰ï¼Œè¿™å°±é€ æˆäº†å¤„ç†é¡ºåºå’Œè®¿é—®é¡ºåºæ˜¯ä¸ä¸€è‡´çš„ã€‚

é‚£ä¹ˆ**åœ¨ä½¿ç”¨è¿­ä»£æ³•å†™ä¸­åºéå†ï¼Œå°±éœ€è¦å€Ÿç”¨æŒ‡é’ˆçš„éå†æ¥å¸®åŠ©è®¿é—®èŠ‚ç‚¹ï¼Œæ ˆåˆ™ç”¨æ¥å¤„ç†èŠ‚ç‚¹ä¸Šçš„å…ƒç´ ã€‚**

## BST

äºŒå‰æŸ¥æ‰¾æ ‘ï¼ˆBSTï¼‰ï¼šæ ¹èŠ‚ç‚¹å¤§äºç­‰äºå·¦å­æ ‘æ‰€æœ‰èŠ‚ç‚¹ï¼Œå°äºç­‰äºå³å­æ ‘æ‰€æœ‰èŠ‚ç‚¹ã€‚

äºŒå‰æŸ¥æ‰¾æ ‘ä¸­åºéå†æœ‰åºã€‚

### 1. ä¿®å‰ªäºŒå‰æŸ¥æ‰¾æ ‘

669\. Trim a Binary Search Tree (Easy)

[Leetcode](https://leetcode.com/problems/trim-a-binary-search-tree/description/) / [åŠ›æ‰£](https://leetcode-cn.com/problems/trim-a-binary-search-tree/description/)

```html
Input:

    3
   / \
  0   4
   \
    2
   /
  1

  L = 1
  R = 3

Output:

      3
     /
   2
  /
 1
```

é¢˜ç›®æè¿°ï¼šåªä¿ç•™å€¼åœ¨ L \~ R ä¹‹é—´çš„èŠ‚ç‚¹

\# ä½¿ç”¨é€’å½’æ–¹æ³•ï¼ŒtrimBSTèƒ½å¤Ÿå¯¹bstè¿›è¡Œä¿®å»ºï¼Œåªè¦æ˜¯ä¸ªbstå°±è¡Œ

â€‹    \# å¯¹bstè¿›è¡Œä¿®å»ºç­‰ä»·äºå¯¹å·¦å³å­æ ‘è¿›è¡Œä¿®å‰ª

â€‹    \# æœ€åŸºæœ¬çš„æƒ…å†µæ˜¯root == None



æœ¬è´¨ï¼š

- è¦æœ‰ä¸€ä¸ªbase caseï¼Œç»ˆæ­¢æ¡ä»¶
- è¦èƒ½å¤Ÿé€æ¸æ¥è¿‘æˆ‘ä»¬çš„ç›®æ ‡
- æ‹¬å·é‡Œé¢æ˜¯å¯å˜çš„å‚æ•°æˆ–è€…éœ€è¦ç”¨åˆ°çš„å‚æ•°ã€‚

```java
public TreeNode trimBST(TreeNode root, int L, int R) {
    if (root == null) return null;
    if (root.val > R) return trimBST(root.left, L, R);
    if (root.val < L) return trimBST(root.right, L, R);
    root.left = trimBST(root.left, L, R);
    root.right = trimBST(root.right, L, R);
    return root;
}
```

### 2. å¯»æ‰¾äºŒå‰æŸ¥æ‰¾æ ‘çš„ç¬¬ k ä¸ªå…ƒç´ 

230\. Kth Smallest Element in a BST (Medium)

[Leetcode](https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/) / [åŠ›æ‰£](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/description/)

ä¸­åºéå†è§£æ³•ï¼š

ç”¨ä¸€ä¸ªå¤–éƒ¨å˜é‡è®°å½•ä¸­åºéå†ç»“æœç¬¬ `k` ä¸ªå…ƒç´ å³æ˜¯ç¬¬ `k` å°çš„å…ƒç´ ã€‚

```java
private int cnt = 0;
private int val;

public int kthSmallest(TreeNode root, int k) {
    inOrder(root, k);
    return val;
}

private void inOrder(TreeNode node, int k) {
    if (node == null) return;
    inOrder(node.left, k);
    cnt++;
    if (cnt == k) {
        val = node.val;
        return;
    }
    inOrder(node.right, k);
}
```

é€’å½’è§£æ³•ï¼š

æ‰¾ç¬¬kä¸ªï¼Œå¯èƒ½æ˜¯å·¦è¾¹å­æ ‘çš„ç¬¬kä¸ªï¼Œrootæœ¬èº«ï¼Œæˆ–è€…å³è¾¹å­æ ‘çš„ç¬¬k-å·¦å­æ ‘-1ä¸ª

```java
public int kthSmallest(TreeNode root, int k) {
    int leftCnt = count(root.left);
    if (leftCnt == k - 1) return root.val;
    if (leftCnt > k - 1) return kthSmallest(root.left, k);
    return kthSmallest(root.right, k - leftCnt - 1);
}

private int count(TreeNode node) {
    if (node == null) return 0;
    return 1 + count(node.left) + count(node.right);
}
```

### 3. æŠŠäºŒå‰æŸ¥æ‰¾æ ‘æ¯ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½åŠ ä¸Šæ¯”å®ƒå¤§çš„èŠ‚ç‚¹çš„å€¼

Convert BST to Greater Tree (Easy)

[Leetcode](https://leetcode.com/problems/convert-bst-to-greater-tree/description/) / [åŠ›æ‰£](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/description/)

```html
Input: The root of a Binary Search Tree like this:

              5
            /   \
           2     13

Output: The root of a Greater Tree like this:

             18
            /   \
          20     13
```

å…ˆéå†å³å­æ ‘ã€‚

\# æŒ‰ç…§bstå³è¾¹å¤§ï¼Œå·¦è¾¹å°çš„æ€§è´¨ã€‚æŒ‰ç…§ä¸­åºéå†ï¼Œä»å³å¾€å·¦éå†è¯¥bstï¼Œè¿™æ ·ç¬¦åˆæœ‰åºçš„æ€§è´¨

â€‹    \# å¯¹bstä¸­åºéå†å°±æ˜¯æœ‰åºçš„éå†

```java
private int sum = 0;

public TreeNode convertBST(TreeNode root) {
    traver(root);
    return root;
}

private void traver(TreeNode node) {
    if (node == null) return;
    traver(node.right);
    sum += node.val;
    node.val = sum;
    traver(node.left);
}
```

### 4. äºŒå‰æŸ¥æ‰¾æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

235\. Lowest Common Ancestor of a Binary Search Tree (Easy)

[Leetcode](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/) / [åŠ›æ‰£](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/)

```html
        _______6______
      /                \
  ___2__             ___8__
 /      \           /      \
0        4         7        9
        /  \
       3   5

For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.
```

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);
    if (root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);
    return root;
}
```

### 5. äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

236\. Lowest Common Ancestor of a Binary Tree (Medium) 

[Leetcode](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/) / [åŠ›æ‰£](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/description/)

```html
       _______3______
      /              \
  ___5__           ___1__
 /      \         /      \
6        2       0        8
        /  \
       7    4

For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.
```

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null || root == p || root == q) return root;
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    return left == null ? right : right == null ? left : root;
}
```

æœ‰ç‚¹éš¾å‘€ï¼š

https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/



æ ¹èŠ‚ç‚¹åˆ°æŸä¸ªèŠ‚ç‚¹çš„è·¯å¾„ã€‚



https://www.youtube.com/watch?v=13m9ZCB8gjw



<img src="https://inews.gtimg.com/newsapp_ls/0/14490272841/0.jiketuchuang.png" alt="image.png" title="image.png" />

<img src="https://inews.gtimg.com/newsapp_ls/0/14490274697/0.jiketuchuang.png" alt="image.png" title="image.png" />

https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/65245/Iterative-Solutions-in-PythonC%2B%2B

è¿­ä»£æ³•ï¼š



æ³¨æ„å‰ä¸­åºéå†çš„é‚£å¼ å›¾ã€‚

<img src="https://inews.gtimg.com/newsapp_ls/0/14490649037/0.jiketuchuang.png" alt="image.png" title="image.png" />









```python
def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        stack=[]
        # getting the path for node p
        stack.append((root,[root]))
        while(stack):
            parent=[]
            s,parent=stack.pop()
            if(s==p):
                break
            if(s.left):
                stack.append((s.left,parent+[s.left]))
            if(s.right):
                stack.append((s.right,parent+[s.right]))
        # getting the path for node q
        stack.append((root,[root.val]))
        while(stack):
            s,parent1=stack.pop()
            if(s==q):
                break
            if(s.left):
                stack.append((s.left, parent1+[s.left]))
            if(s.right):
                stack.append((s.right,parent1+[s.right]))
# we can check from the front for the last such node which is common in both the lists. starting from i=1 since one node is always common in the list the root
        i=1
        while(i<len(parent) and i<len(parent1) and parent[i]==parent1[i]):
                i+=1
        i-=1
        return parent[i] 

```



### 6. ä»æœ‰åºæ•°ç»„ä¸­æ„é€ äºŒå‰æŸ¥æ‰¾æ ‘

108\. Convert Sorted Array to Binary Search Tree (Easy)

[Leetcode](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) / [åŠ›æ‰£](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/description/)

```java
public TreeNode sortedArrayToBST(int[] nums) {
    return toBST(nums, 0, nums.length - 1);
}

private TreeNode toBST(int[] nums, int sIdx, int eIdx){
    if (sIdx > eIdx) return null;
    int mIdx = (sIdx + eIdx) / 2;
    TreeNode root = new TreeNode(nums[mIdx]);
    root.left =  toBST(nums, sIdx, mIdx - 1);
    root.right = toBST(nums, mIdx + 1, eIdx);
    return root;
}
```

[ç®€å•]é€’å½’ï¼ŒğŸ¤·â€â™€ï¸ å¿…é¡»ç§’æ‡‚ï¼](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/solution/jian-dan-di-gui-bi-xu-miao-dong-by-sweetiee/)



### 7. æ ¹æ®æœ‰åºé“¾è¡¨æ„é€ å¹³è¡¡çš„äºŒå‰æŸ¥æ‰¾æ ‘

109\. Convert Sorted List to Binary Search Tree (Medium)

[Leetcode](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/description/) / [åŠ›æ‰£](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/description/)

```html
Given the sorted linked list: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5
```

```java
public TreeNode sortedListToBST(ListNode head) {
    if (head == null) return null;
    if (head.next == null) return new TreeNode(head.val);
    ListNode preMid = preMid(head);
    ListNode mid = preMid.next;
    preMid.next = null;  // æ–­å¼€é“¾è¡¨
    TreeNode t = new TreeNode(mid.val);
    t.left = sortedListToBST(head);
    t.right = sortedListToBST(mid.next);
    return t;
}

private ListNode preMid(ListNode head) {
    ListNode slow = head, fast = head.next;
    ListNode pre = head;
    while (fast != null && fast.next != null) {
        pre = slow;
        slow = slow.next;
        fast = fast.next.next;
    }
    return pre;
}
```

### 8. åœ¨äºŒå‰æŸ¥æ‰¾æ ‘ä¸­å¯»æ‰¾ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œä½¿å®ƒä»¬çš„å’Œä¸ºä¸€ä¸ªç»™å®šå€¼

653\. Two Sum IV - Input is a BST (Easy)

[Leetcode](https://leetcode.com/problems/two-sum-iv-input-is-a-bst/description/) / [åŠ›æ‰£](https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/description/)

```html
Input:

    5
   / \
  3   6
 / \   \
2   4   7

Target = 9

Output: True
```

ä½¿ç”¨ä¸­åºéå†å¾—åˆ°æœ‰åºæ•°ç»„ä¹‹åï¼Œå†åˆ©ç”¨åŒæŒ‡é’ˆå¯¹æ•°ç»„è¿›è¡ŒæŸ¥æ‰¾ã€‚

åº”è¯¥æ³¨æ„åˆ°ï¼Œè¿™ä¸€é¢˜ä¸èƒ½ç”¨åˆ†åˆ«åœ¨å·¦å³å­æ ‘ä¸¤éƒ¨åˆ†æ¥å¤„ç†è¿™ç§æ€æƒ³ï¼Œå› ä¸ºä¸¤ä¸ªå¾…æ±‚çš„èŠ‚ç‚¹å¯èƒ½åˆ†åˆ«åœ¨å·¦å³å­æ ‘ä¸­ã€‚

```java
public boolean findTarget(TreeNode root, int k) {
    List<Integer> nums = new ArrayList<>();
    inOrder(root, nums);
    int i = 0, j = nums.size() - 1;
    while (i < j) {
        int sum = nums.get(i) + nums.get(j);
        if (sum == k) return true;
        if (sum < k) i++;
        else j--;
    }
    return false;
}

private void inOrder(TreeNode root, List<Integer> nums) {
    if (root == null) return;
    inOrder(root.left, nums);
    nums.add(root.val);
    inOrder(root.right, nums);
}
```

### 9. åœ¨äºŒå‰æŸ¥æ‰¾æ ‘ä¸­æŸ¥æ‰¾ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹å·®çš„æœ€å°ç»å¯¹å€¼

530\. Minimum Absolute Difference in BST (Easy)

[Leetcode](https://leetcode.com/problems/minimum-absolute-difference-in-bst/description/) / [åŠ›æ‰£](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/description/)

```html
Input:

   1
    \
     3
    /
   2

Output:

1
```

åˆ©ç”¨äºŒå‰æŸ¥æ‰¾æ ‘çš„ä¸­åºéå†ä¸ºæœ‰åºçš„æ€§è´¨ï¼Œè®¡ç®—ä¸­åºéå†ä¸­ä¸´è¿‘çš„ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹å·®çš„ç»å¯¹å€¼ï¼Œå–æœ€å°å€¼ã€‚æ¯æ¬¡ç¦»å¼€ä¸€ä¸ªèŠ‚ç‚¹çš„æ—¶å€™å°±æŠŠå®ƒè®°å½•ä¸‹æ¥ï¼Œç”¨æ¥å’Œä¸‹ä¸€ä¸ªèŠ‚ç‚¹ä¹‹é—´ä½œå·®ã€‚

```java
private int minDiff = Integer.MAX_VALUE;
private TreeNode preNode = null;

public int getMinimumDifference(TreeNode root) {
    inOrder(root);
    return minDiff;
}

private void inOrder(TreeNode node) {
    if (node == null) return;
    inOrder(node.left);
    if (preNode != null) minDiff = Math.min(minDiff, node.val - preNode.val);
    preNode = node;
    inOrder(node.right);
}
```

### 10. å¯»æ‰¾äºŒå‰æŸ¥æ‰¾æ ‘ä¸­å‡ºç°æ¬¡æ•°æœ€å¤šçš„å€¼

501\. Find Mode in Binary Search Tree (Easy)

[Leetcode](https://leetcode.com/problems/find-mode-in-binary-search-tree/description/) / [åŠ›æ‰£](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/description/)

```html
   1
    \
     2
    /
   2

return [2].
```

ç­”æ¡ˆå¯èƒ½ä¸æ­¢ä¸€ä¸ªï¼Œä¹Ÿå°±æ˜¯æœ‰å¤šä¸ªå€¼å‡ºç°çš„æ¬¡æ•°ä¸€æ ·å¤šã€‚

é¢˜è§£

https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/solution/501-er-cha-sou-suo-shu-zhong-de-zhong-shu-bao-li-t/

æ€è·¯ä¸€ï¼šåˆ©ç”¨bstçš„æ€§è´¨

//ä¸­åºéå†rootï¼Œå¦‚æœä¼—æ•°å‡ºç°ä¸€å®šæ˜¯è¿åœ¨ä¸€èµ·çš„ï¼Œæ‰€ä»¥å¯ä»¥ç”¨countæ¥è¿›è¡Œç´¯åŠ ï¼Œç”¨        

//å› ä¸ºä¼—æ•°æ•°ç›®ä¸ç¡®å®šï¼Œæ‰€ä»¥éœ€è¦ç”¨Listæ¥è£…      

 //æœ€åå†æŠŠListè½¬åŒ–ä¸ºæ•°ç»„

- ä¸­åºéå†
- æ¯”è¾ƒå‰åä¸¤ä¸ªnodeå€¼çš„å¤§å°
- æ±‚ä¸€åˆ—æ•°ä¸­å‡ºç°æ¬¡æ•°æœ€å¤šçš„å‡ ä¸ªæ•°



æ€è·¯äºŒï¼šæš´åŠ›è§£æ³•

ä¸­åºéå†ï¼Œmapè®°å½•æ¯ä¸ªvalueå‡ºç°çš„æ¬¡æ•°

æ±‚ä¸€åˆ—æ•°ä¸­å‡ºç°æ¬¡æ•°æœ€å¤šçš„æ•°ï¼ˆå­˜åœ¨å¤šä¸ªï¼‰ï¼Œä¸mapç»“åˆã€‚

```java
private int curCnt = 1;
private int maxCnt = 1;
private TreeNode preNode = null;

public int[] findMode(TreeNode root) {
    List<Integer> maxCntNums = new ArrayList<>();
    inOrder(root, maxCntNums);
    int[] ret = new int[maxCntNums.size()];
    int idx = 0;
    for (int num : maxCntNums) {
        ret[idx++] = num;
    }
    return ret;
}

private void inOrder(TreeNode node, List<Integer> nums) {
    if (node == null) return;
    inOrder(node.left, nums);
    if (preNode != null) {
        if (preNode.val == node.val) curCnt++;
        else curCnt = 1;
    }
    if (curCnt > maxCnt) {
        maxCnt = curCnt;
        nums.clear();
        nums.add(node.val);
    } else if (curCnt == maxCnt) {
        nums.add(node.val);
    }
    preNode = node;
    inOrder(node.right, nums);
}
```











## Trie

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5c638d59-d4ae-4ba4-ad44-80bdc30f38dd.jpg"/> </div><br>

Trieï¼Œåˆç§°å‰ç¼€æ ‘æˆ–å­—å…¸æ ‘ï¼Œç”¨äºåˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦å­˜åœ¨æˆ–è€…æ˜¯å¦å…·æœ‰æŸç§å­—ç¬¦ä¸²å‰ç¼€ã€‚

### 1. å®ç°ä¸€ä¸ª Trie

208\. Implement Trie (Prefix Tree) (Medium)

[Leetcode](https://leetcode.com/problems/implement-trie-prefix-tree/description/) / [åŠ›æ‰£](https://leetcode-cn.com/problems/implement-trie-prefix-tree/description/)

```java
class Trie {

    private class Node {
        Node[] childs = new Node[26];
        boolean isLeaf;
    }

    private Node root = new Node();

    public Trie() {
    }

    public void insert(String word) {
        insert(word, root);
    }

    private void insert(String word, Node node) {
        if (node == null) return;
        if (word.length() == 0) {
            node.isLeaf = true;
            return;
        }
        int index = indexForChar(word.charAt(0));
        if (node.childs[index] == null) {
            node.childs[index] = new Node();
        }
        insert(word.substring(1), node.childs[index]);
    }

    public boolean search(String word) {
        return search(word, root);
    }

    private boolean search(String word, Node node) {
        if (node == null) return false;
        if (word.length() == 0) return node.isLeaf;
        int index = indexForChar(word.charAt(0));
        return search(word.substring(1), node.childs[index]);
    }

    public boolean startsWith(String prefix) {
        return startWith(prefix, root);
    }

    private boolean startWith(String prefix, Node node) {
        if (node == null) return false;
        if (prefix.length() == 0) return true;
        int index = indexForChar(prefix.charAt(0));
        return startWith(prefix.substring(1), node.childs[index]);
    }

    private int indexForChar(char c) {
        return c - 'a';
    }
}
```

### 2. å®ç°ä¸€ä¸ª Trieï¼Œç”¨æ¥æ±‚å‰ç¼€å’Œ

677\. Map Sum Pairs (Medium)

[Leetcode](https://leetcode.com/problems/map-sum-pairs/description/) / [åŠ›æ‰£](https://leetcode-cn.com/problems/map-sum-pairs/description/)

```html
Input: insert("apple", 3), Output: Null
Input: sum("ap"), Output: 3
Input: insert("app", 2), Output: Null
Input: sum("ap"), Output: 5
```

```java
class MapSum {

    private class Node {
        Node[] child = new Node[26];
        int value;
    }

    private Node root = new Node();

    public MapSum() {

    }

    public void insert(String key, int val) {
        insert(key, root, val);
    }

    private void insert(String key, Node node, int val) {
        if (node == null) return;
        if (key.length() == 0) {
            node.value = val;
            return;
        }
        int index = indexForChar(key.charAt(0));
        if (node.child[index] == null) {
            node.child[index] = new Node();
        }
        insert(key.substring(1), node.child[index], val);
    }

    public int sum(String prefix) {
        return sum(prefix, root);
    }

    private int sum(String prefix, Node node) {
        if (node == null) return 0;
        if (prefix.length() != 0) {
            int index = indexForChar(prefix.charAt(0));
            return sum(prefix.substring(1), node.child[index]);
        }
        int sum = node.value;
        for (Node child : node.child) {
            sum += sum(prefix, child);
        }
        return sum;
    }

    private int indexForChar(char c) {
        return c - 'a';
    }
}
```





### 99% Trie åè¡€æ”»ç•¥ï¼ŒåŒ…æ•™åŒ…ä¼š

https://leetcode-cn.com/problems/short-encoding-of-words/solution/99-java-trie-tu-xie-gong-lue-bao-jiao-bao-hui-by-s/





## [687. æœ€é•¿åŒå€¼è·¯å¾„](https://leetcode.cn/problems/longest-univalue-path/)

```python
class Solution:
    def longestUnivaluePath(self, root: TreeNode) -> int:
        self.res = 0
        def dfs(root):
            if not root: return 0
            left = dfs(root.left)
            right = dfs(root.right)
            
            ## è¿™é‡Œå¿…é¡»è¦è¿™æ ·å¤„ç†çš„åŸå› æ˜¯ï¼Œå·¦è¾¹è¦ä¹ˆä¸º0ï¼Œè¦ä¹ˆä¸ºleft+1, ä¸èƒ½å–left
            ## ä½¿ç”¨åŒå€¼çš„æ•°ç›®ä¹Ÿæ˜¯å¯ä»¥çš„
            left = left + 1 if root.left and root.val == root.left.val else 0
            right = right + 1 if root.right and root.val == root.right.val else 0

            self.res = max(left+right, self.res)
            return max(left, right)

        dfs(root)
        return self.res
```



## [124. äºŒå‰æ ‘ä¸­çš„æœ€å¤§è·¯å¾„å’Œ](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

```python
class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        self.res = float('-inf')
        def dfs(root):
            if not root: return 0
            
            left = max(dfs(root.left), 0)
            right = max(dfs(root.right), 0)
            total = root.val + left + right
            self.res = max(self.res, total)
            return max(left, right) + root.val
        
        dfs(root)
        return self.res
```



[543. äºŒå‰æ ‘çš„ç›´å¾„](https://leetcode.cn/problems/diameter-of-binary-tree/)

```python
class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        ## è·¯å¾„é•¿åº¦å¯ä»¥é€šè¿‡ç»“ç‚¹æ•°ç›®æ¨å‡ºæ¥ï¼Œå› æ­¤åªè¦ç»Ÿè®¡ç»“ç‚¹æ•°ç›®å°±å¯ä»¥äº†
        self.res = 0
        def dfs(root):
            if not root: return 0
            left = dfs(root.left)
            right = dfs(root.right)
            total = left + right
            self.res = max(self.res, total)

            return max(left, right) + 1
        
        dfs(root)
        return self.res


```

