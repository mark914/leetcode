# Leetcode 题解 - 哈希表
<!-- GFM-TOC -->
* [Leetcode 题解 - 哈希表](#leetcode-题解---哈希表)
    * [1. 数组中两个数的和为给定值](#1-数组中两个数的和为给定值) 
      * 遍历nums，看target - num 是否在map中
    * [2. 判断数组是否含有重复元素](#2-判断数组是否含有重复元素)
      * len(nums) != len(set(nums))
    * [3. 最长和谐序列](#3-最长和谐序列)
      * 相差为1的两个数的频次和
    * [4. 最长连续序列](#4-最长连续序列)
      * 判断下一个元素是否存在
    * 
    * <!-- GFM-TOC -->


哈希表使用 O(N) 空间复杂度存储数据，并且以 O(1) 时间复杂度求解问题。

- Java 中的   **HashSet**   用于存储一个集合，可以查找元素是否在集合中。如果元素有穷，并且范围不大，那么可以用一个布尔数组来存储一个元素是否存在。例如对于只有小写字符的元素，就可以用一个长度为 26 的布尔数组来存储一个字符集合，使得空间复杂度降低为 O(1)。

 Java 中的   **HashMap**   主要用于映射关系，从而把两个元素联系起来。HashMap 也可以用来对元素进行计数统计，此时键为元素，值为计数。和 HashSet 类似，如果元素有穷并且范围不大，可以用整型数组来进行统计。在对一个内容进行压缩或者其它转换时，利用 HashMap 可以把原始内容和转换后的内容联系起来。例如在一个简化 url 的系统中 [Leetcdoe : 535. Encode and Decode TinyURL (Medium)

[Leetcode](https://leetcode.com/problems/encode-and-decode-tinyurl/description/)，利用 HashMap 就可以存储精简后的 url 到原始 url 的映射，使得不仅可以显示简化的 url，也可以根据简化的 url 得到原始 url 从而定位到正确的资源�) / [力扣](https://leetcode-cn.com/problems/encode-and-decode-tinyurl/description/)，利用 HashMap 就可以存储精简后的 url 到原始 url 的映射，使得不仅可以显示简化的 url，也可以根据简化的 url 得到原始 url 从而定位到正确的资源�)


## 1. 数组中两个数的和为给定值

1\. Two Sum (Easy)

[Leetcode](https://leetcode.com/problems/two-sum/description/) / [力扣](https://leetcode-cn.com/problems/two-sum/description/)

双指针法：可以先对数组进行排序，然后使用双指针方法或者二分查找方法。这样做的时间复杂度为 O(NlogN)，空间复杂度为 O(1)。

关键：因为要求得到的结果是index，因此我们不能进行排序，否则就会改变val对应的顺序，从而使得求解变得非常困难。

哈希法：用 HashMap 存储数组元素和索引的映射，在访问到 nums[i] 时，判断 HashMap 中是否存在 target - nums[i]，如果存在说明 target - nums[i] 所在的索引和 i 就是要找的两个数。该方法的时间复杂度为 O(N)，空间复杂度为 O(N)，使用空间来换取时间。

关键：

for循环从前往后遍历，也就是hashmap是从前往后添加的。每次查询nums[i]的另一半时，其实就是在在它前面的数里面查找合适的结果。这样就保证了结果的可靠性

```java
public int[] twoSum(int[] nums, int target) {
    HashMap<Integer, Integer> indexForNum = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        if (indexForNum.containsKey(target - nums[i])) {
            return new int[]{indexForNum.get(target - nums[i]), i};
        } else {
            indexForNum.put(nums[i], i);
        }
    }
    return null;
}
```





## 2. 判断数组是否含有重复元素

217\. Contains Duplicate (Easy)

[Leetcode](https://leetcode.com/problems/contains-duplicate/description/) / [力扣](https://leetcode-cn.com/problems/contains-duplicate/description/)

```java
public boolean containsDuplicate(int[] nums) {
    Set<Integer> set = new HashSet<>();
    for (int num : nums) {
        set.add(num);
    }
    return set.size() < nums.length;
}
```

## 3. 最长和谐序列

594\. Longest Harmonious Subsequence (Easy)

[Leetcode](https://leetcode.com/problems/longest-harmonious-subsequence/description/) / [力扣](https://leetcode-cn.com/problems/longest-harmonious-subsequence/description/)

```html
Input: [1,3,2,2,5,2,3,7]
Output: 5
Explanation: The longest harmonious subsequence is [3,2,2,2,3].
```

和谐序列中最大数和最小数之差正好为 1，应该注意的是序列的元素不一定是数组的连续元素。

```java
public int findLHS(int[] nums) {
    Map<Integer, Integer> countForNum = new HashMap<>();
    for (int num : nums) {
        countForNum.put(num, countForNum.getOrDefault(num, 0) + 1);
    }
    int longest = 0;
    for (int num : countForNum.keySet()) {
        if (countForNum.containsKey(num + 1)) {
            longest = Math.max(longest, countForNum.get(num + 1) + countForNum.get(num));
        }
    }
    return longest;
}
```

## 4. 最长连续序列

128\. Longest Consecutive Sequence (Hard)

[Leetcode](https://leetcode.com/problems/longest-consecutive-sequence/description/) / [力扣](https://leetcode-cn.com/problems/longest-consecutive-sequence/description/)

```html
Given [100, 4, 200, 1, 3, 2],
The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.
```

要求以 O(N) 的时间复杂度求解。

```java
public int longestConsecutive(int[] nums) {
    Map<Integer, Integer> countForNum = new HashMap<>();
    for (int num : nums) {
        countForNum.put(num, 1);
    }
    for (int num : nums) {
        forward(countForNum, num);
    }
    return maxCount(countForNum);
}

private int forward(Map<Integer, Integer> countForNum, int num) {
    if (!countForNum.containsKey(num)) {
        return 0;
    }
    int cnt = countForNum.get(num);
    if (cnt > 1) {
        return cnt;
    }
    cnt = forward(countForNum, num + 1) + 1;
    countForNum.put(num, cnt);
    return cnt;
}

private int maxCount(Map<Integer, Integer> countForNum) {
    int max = 0;
    for (int num : countForNum.keySet()) {
        max = Math.max(max, countForNum.get(num));
    }
    return max;
}
```



## [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

在nums中寻找和为target的两个值，并返回它们的下标

关键：因为要返回下标，因此就不能进行排序之后，使用二分查找。就需要使用找到一部分，然后看另一部分是否也在里面。

方法一，brute force：

其实在所有i和j对应的nums值的组合中找到符合条件的组合。

```python
##其實就相当于先固定一部分，然后看另外的部分是否也在里面，看一个元素是否在其中，就可以使用set或者map
##固定i，然後找前面的j
for i in range(1, n):
    for j in range(i):
        if nums[i] + nums[j] == target:
            return [i, j]
return -1
## another approach
## 固定i，然後找後面的j
for i in range(n-1):
    for j in range(i+1, n):
        if nums[i] + nums[j] == target:
            return [i, j]
return -1
```

方法二：hashmap

可以看做是组合问题，其實就相当于先固定一部分，然后看另外的部分是否也在里面，看一个元素是否在其中，就可以使用set或者map。因为最后要的是index，所以需要用val作为索引，index作为值。根据val的性质得到相应的index

```python
dit = dict()
for i in range(len(nums)):
    remain = target - nums[i]
    if remain in dit:
        return [i, dit[remain]]
   	dit[nums[i]] = i
```



## [454. 四数相加 II](https://leetcode-cn.com/problems/4sum-ii/)

给四个整数数组，然后计算有多少个元组(i, j, k, l)能够令使得最后的和为0.和上一题一样，都是先确定一部分，然后再去搞另一部分。

因为要的是满足条件的次数，所以可以先求出三个数的和，然后看第4部分在nums1中出现的次数。也可以先求出两个数的和，然后看剩下两个出现的次数。

方法一：暴力 n**4

方法二：先求出三个，然后再找最后一部分出现的次数

方法三：先求出两个，然后再找最后两部分出现的次数

## [383. 赎金信](https://leetcode-cn.com/problems/ransom-note/)

看前面的在后面是否每个都出现了

**使用滑动窗口中的做法（关键）**

need是前面字符的统计，要求每个字符都能够满足要求

可以设计一个valid字符判断是否满足要求

## [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

找到所有nums中和为0的三个数

分析：本质上是搜索问题，就是搜索满足要求的三个数。这里要的是值，因此就可以使用排序后再二分搜索的方法。

用双指针的方法解决，首先固定第一个数字。然后在在后面用双指针的方法来寻找剩下的部分（两数之和）

关键是在于如何解决重复的问题：

- 找到第一个不相等的点：

  关键，left = nums[i] while l < r and nums[l] == left: l += 1

  这里非常有意思。

- 在外围循环中，从左往右遍历，找到第一个和nums[i]不相等的交接点。while i<n-1 and nums[i] == nums[i+1]: i+=1，这里找到的是左边的，还需要i+=1.



## 例题：

[554. 砖墙](https://leetcode-cn.com/problems/brick-wall/)



