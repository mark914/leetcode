#   Leetcode 题解 - 栈和队列
<!-- GFM-TOC -->

* [Leetcode 题解 - 栈和队列](#leetcode-题解---栈和队列)
    * [1. 用栈实现队列](#1-用栈实现队列)
    * [2. 用队列实现栈](#2-用队列实现栈)
    * [3. 最小值栈](#3-最小值栈)
    * [4. 用栈实现括号匹配](#4-用栈实现括号匹配)
    * 下一个更大元素I 496
    * [5. 数组中元素与下一个比它大的元素之间的距离](#5-数组中元素与下一个比它大的元素之间的距离)
    * [6. 循环数组中比当前元素大的下一个元素](#6-循环数组中比当前元素大的下一个元素)(下一个更大元素II)
    * 柱状图中的最大矩形 84
    * <!-- GFM-TOC -->


## 1. 用栈实现队列

232\. Implement Queue using Stacks (Easy)

[Leetcode](https://leetcode.com/problems/implement-queue-using-stacks/description/) / [力扣](https://leetcode-cn.com/problems/implement-queue-using-stacks/description/)

栈的顺序为后进先出，而队列的顺序为先进先出。使用两个栈实现队列，一个元素需要经过两个栈才能出队列，在经过第一个栈时元素顺序被反转，经过第二个栈时再次被反转，此时就是先进先出顺序。

```java
class MyQueue {

    private Stack<Integer> in = new Stack<>();
    private Stack<Integer> out = new Stack<>();

    public void push(int x) {
        in.push(x);
    }

    public int pop() {
        in2out();
        return out.pop();
    }

    public int peek() {
        in2out();
        return out.peek();
    }

    private void in2out() {
        if (out.isEmpty()) {
            while (!in.isEmpty()) {
                out.push(in.pop());
            }
        }
    }

    public boolean empty() {
        return in.isEmpty() && out.isEmpty();
    }
}
```

思路：

比较好的解决办法是在第一个stack中将添加的数据按照时间从早到晚排列，这样最早出去的就是第一个，pop和peek就不用修改了，就符合queue的性质。达到这个目标需要一个buffer，也就是需要在push的时候进行操作。

使用stack实现queue的时候，要让第一个放在最后面（因为stack会让放在最后一个的先出来）。最后进来的放在最前面。（这里的前后依据stack来说）

```java
class MyQueue {
    private Stack<Integer> queue, buffer;
    
    public MyQueue() {
        queue = new Stack<Integer>();
		buffer = new Stack<Integer>();
    }
    
    public void push(int x) {
        while (!queue.empty()) {
            buffer.push(queue.pop());
        }
        queue.push(x);
        while(!buffer.empty()) {
            queue.push(buffer.pop());
        }
    }
    
    public int pop() {
        return queue.pop();     
    }
    
    public int peek() {
        return queue.peek();
    }
    
    public boolean empty() {
        return queue.empty();
    }
    
    
    
}
```

用python实现的思路感觉非常精妙：

把stack2当做是和队列顺序一样的，这样的话，如果stack2不空，那么久弹出元素就行。否则，如果stack1中有元素，那么在做push和pop的时候，需要先把stack1中的元素颠倒到stack2中。





```python
class MyQueue(object):
    
    def __init__(self):
        self.stack1 = []
        self.stack2 = []
      
    def push(self, x):
        self.stack1.append(x)
        
    def pop(self):
        if self.stack2:
            self.stack2.pop()
		else:
            while self.stack1:
                self.stack2.append(self.stack1.pop())
                
            return self.stack2.pop()
   	def peek(self):
        if self.stack2:
            return self.stack2[-1]
        else:
            while self.stack1:
                self.stack2.append(self.stack1.pop())
            return self.stack2[-1]
	def empty(self):
        return not self.stack1 and not self.stack2

```



## 2. 用队列实现栈

225\. Implement Stack using Queues (Easy)

[Leetcode](https://leetcode.com/problems/implement-stack-using-queues/description/) / [力扣](https://leetcode-cn.com/problems/implement-stack-using-queues/description/)

在将一个元素 x 插入队列时，为了维护原来的后进先出顺序，需要让 x 插入队列首部。而队列的默认插入顺序是队列尾部，因此在将 x 插入队列尾部之后，需要让除了 x 之外的所有元素出队列，再入队列。



用递归的方式思考，假设queue1里面的元素已经是按照stack的顺序排好了，现在新加一个x，如何让它能够第一个出去。从后面进，但是能从第一个出去，要保证queue1里只有x一个元素。

```java
class MyStack {

    private Queue<Integer> queue;

    public MyStack() {
        queue = new LinkedList<>();
    }

    public void push(int x) {
        queue.add(x);
        int cnt = queue.size();
        while (cnt-- > 1) {
            queue.add(queue.poll());
        }
    }

    public int pop() {
        return queue.remove();
    }

    public int top() {
        return queue.peek();
    }

    public boolean empty() {
        return queue.isEmpty();
    }
}
```

思路：queue先进先出 ， stack 后进先出。

用queue表示stack，也就要让最后一个进来的放在最前面的位置。

queue是一种特殊的线性表，先进先出，LinkedList class实现来queue的接口，因此可以把LinkedList当做queue来用。

- offer
- poll
- peek





## 3. 最小值栈

155\. Min Stack (Easy)

[Leetcode](https://leetcode.com/problems/min-stack/description/) / [力扣](https://leetcode-cn.com/problems/min-stack/description/)

```java
class MinStack {

    private Stack<Integer> dataStack;
    private Stack<Integer> minStack;
    private int min;

    public MinStack() {
        dataStack = new Stack<>();
        minStack = new Stack<>();
        min = Integer.MAX_VALUE;
    }

    public void push(int x) {
        dataStack.add(x);
        min = Math.min(min, x);
        minStack.add(min);
    }

    public void pop() {
        dataStack.pop();
        minStack.pop();
        min = minStack.isEmpty() ? Integer.MAX_VALUE : minStack.peek();
    }

    public int top() {
        return dataStack.peek();
    }

    public int getMin() {
        return minStack.peek();
    }
}
```

对于实现最小值队列问题，可以先将队列使用栈来实现，然后就将问题转换为最小值栈，这个问题出现在 编程之美：3.7。

思路：

- 使用两个stack来解决问题，一个stack是正常的，另一个stack保存最小值。
- stack 和 minStack的规模大小是一样的
- 每次添加一个num，都要追踪现有的最小值
- 没次remove一个num，都要remove一个最小值

```java
class MinStack {
    Stack<Integer> stack, minStack;
    
    public MinStack() {
        stack = new Stack<Integer>();
		minStack = new Stack<Integer>();
    }
    
    void push(int x) {
        stack.push(x);
        if (minStack.empty()) {
            minStack.push(x);
        } else{
            int oldMin = minStack.peek();
            int newMin = (x < oldMin) ? x: oldMin;
            minStack.push(newMin);
        }
    }
    
    void pop() {
        stack.pop();
        minStack.pop();
	}
    
    int top() {
        return stack.peek();
    }
    
    int getMin() {
        return minStack.peek();
    }
        
}
```

只有栈才能得到最小值栈：因为维护最小值栈的时候，每次都需要考虑新进来的元素是否为最小值，也就是后进来的元素有最先出去的可能，这符合栈后进先出的特点。因此需要用栈来实现最小值栈



## 4. 用栈实现括号匹配

20\. Valid Parentheses (Easy)

[Leetcode](https://leetcode.com/problems/valid-parentheses/description/) / [力扣](https://leetcode-cn.com/problems/valid-parentheses/description/)

```html
"()[]{}"

Output : true
```

```java
public boolean isValid(String s) {
    Stack<Character> stack = new Stack<>();
    for (char c : s.toCharArray()) {
        if (c == '(' || c == '{' || c == '[') {
            stack.push(c);
        } else {
            if (stack.isEmpty()) {
                return false;
            }
            char cStack = stack.pop();
            boolean b1 = c == ')' && cStack != '(';
            boolean b2 = c == ']' && cStack != '[';
            boolean b3 = c == '}' && cStack != '{';
            if (b1 || b2 || b3) {
                return false;
            }
        }
    }
    return stack.isEmpty();
}
```

理解题目的意图：

有效括号需要满足：

左括号必须要有相同类型的有括号闭合。（长度必须为偶数）

左括号必须要以正确的顺序闭合。

如果遇到左括号则放到stack里，每遇到一个右括号就用顶部的左括号和它对应。最先进入的左括号会最后出去，因此是stack。

思路：

edge case：如果都为左括号，或者都为右边括号。

如何判断左右括号是匹配的呢，使用map。key为右边括号，val为左边括号。

使用stack解决，对s进行遍历，分两种情况：

- 如果为左括号，则push到stack中，
- 如果为右括号，则看stack中是否有与之相匹配的左括号（使用map）。

最后stack中应该是没有数据的。

```java
public boolean isValid(String s) {
    // 左右括号的对应关系,使用map
    // 遍历整个string s，
    //左括号push进stack（后进先出）
    //右括号判断stack中是否有对应括号。
    if (s.length() % 2 != 0) return false;
    Stack<Integer> stack = new Stack<>();
    Map<Character, Character> map = new HashMap<>();
    map.put(')', '(');
    map.put('}', '{');
    map.put(']', '[');
    
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        if (!map.containsKey(c)) {
            stack.push(c);
        } else {
            if (stack.empty() || stack.pop() != map.get(c)) {
                return false;
            }
        }
    }
    return stack.empty();
    
}
```

## 括号相关题目：

[20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

消消乐

最后stack长度为0

[22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)

考虑多种情况

left, right 减小到什么时候为止 left < 0 or right < 0

什么时候可以取结果 left == 0 and right == 0

[32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)

dp[i]表示以nums[i]结尾的最长有效括号

要考虑的很细致，关键是看该位置能不能和前面的结合形成括号

[301. 删除无效的括号](https://leetcode.cn/problems/remove-invalid-parentheses/)

首先要知道应该删除多少左括号和多少右括号

然后要能够判断是否为有效括号组

最后通过回溯算法（相当于求组合）得到最后的结果

​	通过l， r来控制回溯的开始和结束



[1249. 移除无效的括号](https://leetcode.cn/problems/minimum-remove-to-make-valid-parentheses/)

- 使用栈的方法，首先得到需要删除的括号位置
  - 栈中只保留多余（ 的位置
- 然后一次遍历，将不是这些位置的括号保留下来即可

### 

## 移除k位数字问题

[402. 移掉 K 位数字](https://leetcode.cn/problems/remove-k-digits/)

维护一个单调递增的栈，pop一个结果则k减去1，知道k = 0时，停止

注意完全递增的情况，有前导0的情况，为空字符串的情况

[321. 拼接最大数](https://leetcode.cn/problems/create-maximum-number/)

两个数组里面共取k个数，最后结果最大

分别从A和B中取i个数和k-i个数， 取k个数相当于删掉len(A) - k个数，相当于402

最后将从A和B中得到的两个数合并在一起，使用归并排序里面的方法

[738. 单调递增的数字](https://leetcode.cn/problems/monotone-increasing-digits/)

找到不合符规则的部分，然后将前面的减一，后面的全部变成9

[316. 去除重复字母](https://leetcode.cn/problems/remove-duplicate-letters/)

对每个字符都要删除k-1个，这里可以用set()来防止出现重复的

[1081. 不同字符的最小子序列](https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters/)

## 5. 数组中元素与下一个比它大的元素之间的距离

739\. Daily Temperatures (Medium)

[Leetcode](https://leetcode.com/problems/daily-temperatures/description/) / [力扣](https://leetcode-cn.com/problems/daily-temperatures/description/)

```html
Input: [73, 74, 75, 71, 69, 72, 76, 73]
Output: [1, 1, 4, 2, 1, 1, 0, 0]
```

在遍历数组时用栈把数组中的数存起来，如果当前遍历的数比栈顶元素来的大，说明栈顶元素的下一个比它大的数就是当前元素。

判别是否需要使用单调栈，如果需要找到左边或者右边第一个比当前位置的数大或者小，则可以考虑使用单调栈；单调栈的题目如矩形米面积等等

- **单调栈中存储的是index**，结果需要的是index之间的差。对于每个index，找到第一个比它大的数的index，然后两者之差就是该位置结果的值。
- 注意，初始化时结果中每个位置的值都为0；
- 注意，要使用val来确定index的顺序

```java
public int[] dailyTemperatures(int[] temperatures) {
    int n = temperatures.length;
    int[] dist = new int[n];
    Stack<Integer> indexs = new Stack<>();
    for (int curIndex = 0; curIndex < n; curIndex++) {
        while (!indexs.isEmpty() && temperatures[curIndex] > temperatures[indexs.peek()]) {
            int preIndex = indexs.pop();
            dist[preIndex] = curIndex - preIndex;
        }
        indexs.add(curIndex);
    }
    return dist;
}
```

思路1：使用双循环，这个思路是最简单的。对于每一个元素i，都遍历其后的元素，如果大于，则用其index-i得到结果。 最后一个元素的结果一定为0.

array的性质。需要记忆一下

queue的性质。

map的性质。

stack的性质。

思路2：使用单调栈，感觉有点难，不太容易想得到。

参考：https://zhuanlan.zhihu.com/p/26465701（浅谈单调栈）

单调栈：

- 需要在单调栈里维护的是元素的索引
- 单调栈是一个单调递减的栈
- 元素出站时，则遇到下一个更大元素；如果没有出站，则说明不存在下一个最大元素。因此需要给res赋予初始值。
- **我们也可以使用map来记录下一个更大值的结果。这时，只有那些有下一个更大值的才会在map中有键。**（下一个最大值I）



我们维护这样一个单调递减的stack，stack内部存的是原数组的每个index。每当我们遇到一个比当前栈顶所对应的数（就是input[monoStack.top()]）大的数的时候，我们就遇到了一个“大数“。这个”大数“比它之前多少个数大我们不知道，但是至少比当前栈顶所对应的数大。我们弹出栈内所有对应数比这个数小的栈内元素，并更新它们在返回数组中对应位置的值。因为这个栈本身的单调性，当我们栈顶元素所对应的数比这个元素大的时候，我们可以保证，栈内所有元素都比这个元素大。对于每一个元素，当它出栈的时候，说明它遇到了自己的next greater element，我们也就要更新return数组中的对应位置的值。如果一个元素一直不曾出栈，那么说明不存在next greater element，我们也就不用更新return数组了。



## 6. 循环数组中比当前元素大的下一个元素

503\. Next Greater Element II (Medium)

[Leetcode](https://leetcode.com/problems/next-greater-element-ii/description/) / [力扣](https://leetcode-cn.com/problems/next-greater-element-ii/description/)

```text
Input: [1,2,1]
Output: [2,-1,2]
Explanation: The first 1's next greater number is 2;
The number 2 can't find next greater number;
The second 1's next greater number needs to search circularly, which is also 2.
```

与 739. Daily Temperatures (Medium) 不同的是，数组是循环数组，并且最后要求的不是距离而是下一个元素。

给出每个位置 比它大 的第一个数，可以使用循环数组。 维护一个单调数组，如果stack为空，则直接添加；否则比较该值和stack中index对应数值的大小，如果小的话，也直接push，如果大于的话，则可以将index对应的数值定位为该值。

```java
public int[] nextGreaterElements(int[] nums) {
    int n = nums.length;
    int[] next = new int[n];
    Arrays.fill(next, -1);
    Stack<Integer> pre = new Stack<>();
    for (int i = 0; i < n * 2; i++) {
        int num = nums[i % n];
        while (!pre.isEmpty() && nums[pre.peek()] < num) {
            next[pre.pop()] = num;
        }
        if (i < n){
            pre.push(i);
        }
    }
    return next;
}
```



对每一个位置，循环遍历，对应结果为第一个大于它的值；如果没有找到，结果为-1；

思路：

- 首先创建ret，并填充为-1

- 双层循环：
  - 外层循环对index进行遍历
  - 内层循环对index之外的位置进行循环遍历
    - 如果找到更大的则进行赋值，并打断内层循环（因为要找到大于它的第一个数）
  
  ```python
  res = [-1] * n
  stack = deque()
  for i in range(2*n):
      while stack and nums[stack[-1]] < nums[i % n]:
          preIndex = stack.pop()
          res[preIndex] = nums[i % n]
      if i < n:
          stack.append(i)
  
  res = [-1] * n
  for i in range(n):
      for j in range(i + 1, n + i):
          if nums[j] > nums[i]:
              res[i] = nums[j]
              break
  return res
  ```
  
  

## 7 柱状图中最大的矩形

 对每个height 都计算一个面积，然后求出所有面积中的最大值。当一个元素出列的时候，就能够计算它的面积了。

 单调增的栈，能够找到左边和右边第一个小于它的index。因为递增所以左边的那个就是第一个小于它的。右边的那个就是当前遇到的index。为了让每个height都存在左右两边的边界，就在list的两端分别补上一个0.



## 8、接雨水

考虑仅仅对于位置 `i`，能装下多少水

**位置 i 最大的水柱高度就是 `min(l_max, r_max) - nums[i]`。**

方法一：对每个idx i，求出其左边最大值l_max[i]和右边最大值r_max[i]，然后求出结果

方法二：双指针方法，求出[0, l] 和 [r, len(nums)-1]的最大值l_max 和 r_max， 如果l_max < r_max, 那么idx = l能够接水的量就确定了，为l_max - nums[l]， 同理， 如果l_max >= r_max, 那么idx = r的接水量确定了，为r_max - nums[r]。 可以这样做的原因是，我们要的是idx左右两边第一个最大值中较小的那一个，只要找到较小的那个就可以了，至于右边那个是不是最大的我们并不关心。

方法三：单调栈 当遍历墙的高度的时候，如果当前高度小于栈顶的墙高度，说明这里会有积水，我们将墙的高度的下标入栈。如果当前高度大于栈顶的墙的高度，说明之前的积水到这里停下，我们可以计算下有多少积水了。计算完，就把当前的墙继续入栈，作为新的积水的墙

关键：形成积水需要左右两边都有墙，从而能够形成凹槽，这样才可以。



## [1047. 删除字符串中的所有相邻重复项](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/)

消消乐



### [347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

小顶堆

### 单调栈和单调队列

两者之间的关系：

这就和最小栈问题很像，唯一不同的一点就是：最小栈问题中新 Push 进去的值（也就是可能对当前最小值产生影响的值）也是先弹出，这样剩下的部分之前求解的最小值不会被改变。在本问题中，因为队列先进先出的特性，当前的最大值不光受新加入的值的影响，同时也受出队的值的影响。

单调栈：

单调递减栈：获取左右两边第一个大于等于它的值，准确来说，右边是大于它的第一个，左边是大于等于它的第一个。

单调递增栈：获取左右两边第一个小于等于它的值，准确来说，右边是小于它的第一个，左边是小于等于它的第一个。

这里左右的区别主要是在while处产生的

单调队列：

单调队列详解 https://blog.csdn.net/er111er/article/details/78344161

几个例题：

https://blog.csdn.net/qq_39924622/article/details/106892343

### 例题

[1081. 不同字符的最小子序列](https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters/)

[321. 拼接最大数](https://leetcode-cn.com/problems/create-maximum-number/)

[316. 去除重复字母](https://leetcode-cn.com/problems/remove-duplicate-letters/)

[227. 基本计算器 II](https://leetcode-cn.com/problems/basic-calculator-ii/)
